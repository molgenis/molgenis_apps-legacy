
<html>

<head>
	<title>hemodb TAB exchange format reference documentation</title>
	
	<meta name="keywords"			content="">
	<meta name="description"		content="">
	<meta http-equiv="Contect-Type"	content="text/html; charset-UTF-8">
	
	<style type="text/css">
		body
		{
			background:		#ffffff;
			color:			#000000;
			font-family:	arial, sans-serif;
			font-size:		10pt;
		}
		
		td
		{
			font-family:	arial, sans-serif;
			font-size:		10pt;
			vertical-align: top;
		}
		.tablehead
		{
			background:		#888888;
			color:			#ffffff;
			text-align:		left;
			font-family:	arial, sans-serif;
			font-size:		10pt;
			font-weight:	bold;
		}
		th
		{
			font-family:	arial, sans-serif;
			font-size:		10pt;
			font-weight:	bold;
		}
	</style>
</head>



<body>
<h1>Human leukemia database file format reference</h1>
<p>
This is documentation on the data exchange format for the 'Human leukemia database' system. 
</p>
<p>To ease data exchange this system comes with a simple 'tab separated values' file format. 
In such text files the data is formatted in tables with the columns separated using tabs, colons, or semi-colons.
Advantage is that these files can be easily created and parsed using common spreadsheet tools like Excel. 
An example of such tab delimited file is shown below:
<pre>
name	description	date
Experiment1	This is my first experiment	2010-01-19
Experiment2	This is my second experiment	2010-01-20
</pre>
This document describes what file types and columns are defined for the 'Human leukemia database' system. 
Data in this format can be uploaded to the database via the user interface using the 'File' menu). 
Alternatively, a whole directory of such files can be loaded in batch using the CsvImport program. 
The following files are currently recognized by this program (grouped by topic):
</p>
<!-- per module -->
<ul>
<li><b>org.molgenis.auth</b> files:
<ul>
<li><a href="#molgenisRole_entity">molgenisrole.txt</a>
<li><a href="#molgenisGroup_entity">molgenisgroup.txt</a>
<li><a href="#molgenisRoleGroupLink_entity">molgenisrolegrouplink.txt</a>
<li><a href="#person_entity">person.txt</a>
<li><a href="#institute_entity">institute.txt</a>
<li><a href="#molgenisUser_entity">molgenisuser.txt</a>
<li><a href="#molgenisPermission_entity">molgenispermission.txt</a>
</ul>
</li>
<li><b>org.molgenis.core</b> files:
<ul>
<li><a href="#ontologyTerm_entity">ontologyterm.txt</a>
<li><a href="#ontology_entity">ontology.txt</a>
<li><a href="#molgenisFile_entity">molgenisfile.txt</a>
<li><a href="#runtimeProperty_entity">runtimeproperty.txt</a>
<li><a href="#publication_entity">publication.txt</a>
<li><a href="#useCase_entity">usecase.txt</a>
<li><a href="#molgenisEntity_entity">molgenisentity.txt</a>
</ul>
</li>
<li><b>org.molgenis.data</b> files:
<ul>
<li><a href="#observedInference_entity">observedinference.txt</a>
<li><a href="#dataFile_entity">datafile.txt</a>
<li><a href="#data_entity">data.txt</a>
<li><a href="#binaryDataMatrix_entity">binarydatamatrix.txt</a>
<li><a href="#cSVDataMatrix_entity">csvdatamatrix.txt</a>
<li><a href="#decimalDataElement_entity">decimaldataelement.txt</a>
<li><a href="#textDataElement_entity">textdataelement.txt</a>
<li><a href="#originalFile_entity">originalfile.txt</a>
</ul>
</li>
<li><b>org.molgenis.organization</b> files:
<ul>
<li><a href="#investigation_entity">investigation.txt</a>
</ul>
</li>
<li><b>org.molgenis.pheno</b> files:
<ul>
<li><a href="#species_entity">species.txt</a>
<li><a href="#alternateId_entity">alternateid.txt</a>
<li><a href="#observationElement_entity">observationelement.txt</a>
<li><a href="#observationTarget_entity">observationtarget.txt</a>
<li><a href="#observableFeature_entity">observablefeature.txt</a>
<li><a href="#measurement_entity">measurement.txt</a>
<li><a href="#category_entity">category.txt</a>
<li><a href="#individual_entity">individual.txt</a>
<li><a href="#location_entity">location.txt</a>
<li><a href="#panel_entity">panel.txt</a>
<li><a href="#observedValue_entity">observedvalue.txt</a>
</ul>
</li>
<li><b>org.molgenis.protocol</b> files:
<ul>
<li><a href="#protocol_entity">protocol.txt</a>
<li><a href="#protocolApplication_entity">protocolapplication.txt</a>
<li><a href="#protocolDocument_entity">protocoldocument.txt</a>
<li><a href="#workflow_entity">workflow.txt</a>
<li><a href="#workflowElement_entity">workflowelement.txt</a>
<li><a href="#workflowElementParameter_entity">workflowelementparameter.txt</a>
</ul>
</li>
<li><b>org.molgenis.xgap</b> files:
<ul>
<li><a href="#chromosome_entity">chromosome.txt</a>
<li><a href="#nMRBin_entity">nmrbin.txt</a>
<li><a href="#clone_entity">clone.txt</a>
<li><a href="#derivedTrait_entity">derivedtrait.txt</a>
<li><a href="#environmentalFactor_entity">environmentalfactor.txt</a>
<li><a href="#gene_entity">gene.txt</a>
<li><a href="#transcript_entity">transcript.txt</a>
<li><a href="#protein_entity">protein.txt</a>
<li><a href="#metabolite_entity">metabolite.txt</a>
<li><a href="#marker_entity">marker.txt</a>
<li><a href="#sNP_entity">snp.txt</a>
<li><a href="#polymorphism_entity">polymorphism.txt</a>
<li><a href="#probe_entity">probe.txt</a>
<li><a href="#spot_entity">spot.txt</a>
<li><a href="#probeSet_entity">probeset.txt</a>
<li><a href="#massPeak_entity">masspeak.txt</a>
<li><a href="#investigationFile_entity">investigationfile.txt</a>
<li><a href="#tissue_entity">tissue.txt</a>
<li><a href="#sampleLabel_entity">samplelabel.txt</a>
<li><a href="#sample_entity">sample.txt</a>
<li><a href="#pairedSample_entity">pairedsample.txt</a>
</ul>
</li>
<li><b>org.molgenis.cluster</b> files:
<ul>
<li><a href="#job_entity">job.txt</a>
<li><a href="#subjob_entity">subjob.txt</a>
<li><a href="#analysis_entity">analysis.txt</a>
<li><a href="#parameterSet_entity">parameterset.txt</a>
<li><a href="#parameterName_entity">parametername.txt</a>
<li><a href="#parameterValue_entity">parametervalue.txt</a>
<li><a href="#dataSet_entity">dataset.txt</a>
<li><a href="#dataName_entity">dataname.txt</a>
<li><a href="#dataValue_entity">datavalue.txt</a>
<li><a href="#selectedParameter_entity">selectedparameter.txt</a>
<li><a href="#selectedData_entity">selecteddata.txt</a>
<li><a href="#rScript_entity">rscript.txt</a>
</ul>
</li>
<li><b>org.molgenis.hemodb</b> files:
<ul>
<li><a href="#hemoSample_entity">hemosample.txt</a>
<li><a href="#hemoGene_entity">hemogene.txt</a>
<li><a href="#hemoProbe_entity">hemoprobe.txt</a>
<li><a href="#hemoSampleGroup_entity">hemosamplegroup.txt</a>
</ul>
</li>
<!-- outside module -->
<li><b>Human leukemia database</b> files:
<ul>
<li><a href="#molgenisRole_entity">molgenisrole.txt</a>
<li><a href="#molgenisGroup_entity">molgenisgroup.txt</a>
<li><a href="#molgenisRoleGroupLink_entity">molgenisrolegrouplink.txt</a>
<li><a href="#person_entity">person.txt</a>
<li><a href="#institute_entity">institute.txt</a>
<li><a href="#molgenisUser_entity">molgenisuser.txt</a>
<li><a href="#molgenisPermission_entity">molgenispermission.txt</a>
<li><a href="#ontologyTerm_entity">ontologyterm.txt</a>
<li><a href="#ontology_entity">ontology.txt</a>
<li><a href="#molgenisFile_entity">molgenisfile.txt</a>
<li><a href="#runtimeProperty_entity">runtimeproperty.txt</a>
<li><a href="#publication_entity">publication.txt</a>
<li><a href="#useCase_entity">usecase.txt</a>
<li><a href="#molgenisEntity_entity">molgenisentity.txt</a>
<li><a href="#observedInference_entity">observedinference.txt</a>
<li><a href="#dataFile_entity">datafile.txt</a>
<li><a href="#data_entity">data.txt</a>
<li><a href="#binaryDataMatrix_entity">binarydatamatrix.txt</a>
<li><a href="#cSVDataMatrix_entity">csvdatamatrix.txt</a>
<li><a href="#decimalDataElement_entity">decimaldataelement.txt</a>
<li><a href="#textDataElement_entity">textdataelement.txt</a>
<li><a href="#originalFile_entity">originalfile.txt</a>
<li><a href="#investigation_entity">investigation.txt</a>
<li><a href="#species_entity">species.txt</a>
<li><a href="#alternateId_entity">alternateid.txt</a>
<li><a href="#observationElement_entity">observationelement.txt</a>
<li><a href="#observationTarget_entity">observationtarget.txt</a>
<li><a href="#observableFeature_entity">observablefeature.txt</a>
<li><a href="#measurement_entity">measurement.txt</a>
<li><a href="#category_entity">category.txt</a>
<li><a href="#individual_entity">individual.txt</a>
<li><a href="#location_entity">location.txt</a>
<li><a href="#panel_entity">panel.txt</a>
<li><a href="#observedValue_entity">observedvalue.txt</a>
<li><a href="#protocol_entity">protocol.txt</a>
<li><a href="#protocolApplication_entity">protocolapplication.txt</a>
<li><a href="#protocolDocument_entity">protocoldocument.txt</a>
<li><a href="#workflow_entity">workflow.txt</a>
<li><a href="#workflowElement_entity">workflowelement.txt</a>
<li><a href="#workflowElementParameter_entity">workflowelementparameter.txt</a>
<li><a href="#chromosome_entity">chromosome.txt</a>
<li><a href="#nMRBin_entity">nmrbin.txt</a>
<li><a href="#clone_entity">clone.txt</a>
<li><a href="#derivedTrait_entity">derivedtrait.txt</a>
<li><a href="#environmentalFactor_entity">environmentalfactor.txt</a>
<li><a href="#gene_entity">gene.txt</a>
<li><a href="#transcript_entity">transcript.txt</a>
<li><a href="#protein_entity">protein.txt</a>
<li><a href="#metabolite_entity">metabolite.txt</a>
<li><a href="#marker_entity">marker.txt</a>
<li><a href="#sNP_entity">snp.txt</a>
<li><a href="#polymorphism_entity">polymorphism.txt</a>
<li><a href="#probe_entity">probe.txt</a>
<li><a href="#spot_entity">spot.txt</a>
<li><a href="#probeSet_entity">probeset.txt</a>
<li><a href="#massPeak_entity">masspeak.txt</a>
<li><a href="#investigationFile_entity">investigationfile.txt</a>
<li><a href="#tissue_entity">tissue.txt</a>
<li><a href="#sampleLabel_entity">samplelabel.txt</a>
<li><a href="#sample_entity">sample.txt</a>
<li><a href="#pairedSample_entity">pairedsample.txt</a>
<li><a href="#job_entity">job.txt</a>
<li><a href="#subjob_entity">subjob.txt</a>
<li><a href="#analysis_entity">analysis.txt</a>
<li><a href="#parameterSet_entity">parameterset.txt</a>
<li><a href="#parameterName_entity">parametername.txt</a>
<li><a href="#parameterValue_entity">parametervalue.txt</a>
<li><a href="#dataSet_entity">dataset.txt</a>
<li><a href="#dataName_entity">dataname.txt</a>
<li><a href="#dataValue_entity">datavalue.txt</a>
<li><a href="#selectedParameter_entity">selectedparameter.txt</a>
<li><a href="#selectedData_entity">selecteddata.txt</a>
<li><a href="#rScript_entity">rscript.txt</a>
<li><a href="#hemoSample_entity">hemosample.txt</a>
<li><a href="#hemoGene_entity">hemogene.txt</a>
<li><a href="#hemoProbe_entity">hemoprobe.txt</a>
<li><a href="#hemoSampleGroup_entity">hemosamplegroup.txt</a>
</ul>
</li>
</ul>
Below, the columns for each of these file types are detailed as well as example data shown (if available).


<!-- entities inside modules -->
<h2>org.molgenis.auth file types</h2>

<h3 id="molgenisRole_entity">File: molgenisrole.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="molgenisGroup_entity">File: molgenisgroup.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="molgenisRoleGroupLink_entity">File: molgenisrolegrouplink.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">group__name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>group_.
		This xref uses {group__name} to find related elements in file <a href="#molgenisGroup_entity">molgenisGroup.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">role__name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>role_.
		This xref uses {role__name} to find related elements in file <a href="#molgenisRole_entity">molgenisRole.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="person_entity">File: person.txt</h3> 
<p>Contents:<br> 

				Person represents one or more people involved with an Investigation.
				This may include authors on a paper, lab personnel or PIs. Person
				has last name, firstname, mid initial, address, contact and email. A
				Person role is included to represent how a Person is involved with
				an investigation. For submission to repository purposes an allowed
				value is 'submitter' and the term is present in the MGED Ontology,
				an alternative use could represent job title. An Example from
				ArrayExpress is E-MTAB-506
				<a href="ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt">
					ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt.
				</a>
				.
				<br/>
				The FUGE equivalent to Person is FuGE::Person.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<tr>
		<td width="150">address</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">phone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The telephone number of the Contact including the suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">email</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The email address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">fax</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The fax number of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">tollfreephone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>A toll free phone number for the Contact, including suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">city</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. City of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">country</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Country of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">firstname</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>First Name.<br></td>
	</tr>
	<tr>
		<td width="150">midinitials</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Mid Initials.<br></td>
	</tr>
	<tr>
		<td width="150">lastname</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Last Name.<br></td>
	</tr>
	<tr>
		<td width="150">title</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>An academic title, e.g. Prof.dr, PhD.<br></td>
	</tr>
	<tr>
		<td width="150">affiliation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Affiliation.
		This xref uses {affiliation_name} to find related elements in file <a href="#institute_entity">institute.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">department</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Department of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">roles_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicate role of the contact, e.g. lab worker or PI. Changed from mref to xref in oct 2011..
		This xref uses {roles_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (firstname, midinitials, lastname) should be unique.</td></tr>
</table>
</p>


<h3 id="institute_entity">File: institute.txt</h3> 
<p>Contents:<br>  A contact is either a person or an organization. Copied
				from FuGE::Contact.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">address</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">phone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The telephone number of the Contact including the suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">email</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The email address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">fax</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The fax number of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">tollfreephone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>A toll free phone number for the Contact, including suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">city</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. City of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">country</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Country of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="molgenisUser_entity">File: molgenisuser.txt</h3> 
<p>Contents:<br> Anyone who can login
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<tr>
		<td width="150">address</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">phone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The telephone number of the Contact including the suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">email</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The email address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">fax</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The fax number of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">tollfreephone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>A toll free phone number for the Contact, including suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">city</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. City of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">country</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Country of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">firstname</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>First Name.<br></td>
	</tr>
	<tr>
		<td width="150">midinitials</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Mid Initials.<br></td>
	</tr>
	<tr>
		<td width="150">lastname</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Last Name.<br></td>
	</tr>
	<tr>
		<td width="150">title</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>An academic title, e.g. Prof.dr, PhD.<br></td>
	</tr>
	<tr>
		<td width="150">affiliation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Affiliation.
		This xref uses {affiliation_name} to find related elements in file <a href="#institute_entity">institute.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">department</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Department of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">roles_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicate role of the contact, e.g. lab worker or PI. Changed from mref to xref in oct 2011..
		This xref uses {roles_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">password_</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">secret</td>
		<td>big fixme: password type.<br></td>
	</tr>
	<tr>
		<td width="150">activationcode</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Used as alternative authentication mechanism to verify user email and/or if user has lost password.<br></td>
	</tr>
	<tr>
		<td width="150">active</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>Boolean to indicate if this account can be used to login.<br></td>
	</tr>
	<tr>
		<td width="150">superuser</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>superuser.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (firstname, midinitials, lastname) should be unique.</td></tr>
</table>
</p>


<h3 id="molgenisPermission_entity">File: molgenispermission.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">role__name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>role_.
		This xref uses {role__name} to find related elements in file <a href="#molgenisRole_entity">molgenisRole.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">entity_className<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>entity.
		This xref uses {entity_classname} to find related elements in file <a href="#molgenisEntity_entity">molgenisEntity.txt</a> based on unique column {classname}.
		</td>
	</tr>	
	<tr>
		<td width="150">permission</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>permission.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h2>org.molgenis.core file types</h2>
<p>Generic entities you can use as the starting point of
			your model.
</p>
<h3 id="ontologyTerm_entity">File: ontologyterm.txt</h3> 
<p>Contents:<br> 
				OntologyTerm defines a single entry (term) from an ontology or a
				controlled vocabulary (defined by Ontology). The name is the
				ontology term which is unique within an ontology source, such as
				[examples here]. Other data entities can reference to this
				OntologyTerm to harmonize naming of concepts. Each term should have
				a local, unique label within the Investigation. If no suitable
				ontology term exists then one can define new terms locally (in which
				case there is no formal accession for the term limiting its use for
				cross-Investigation queries). In those cases the local name should
				be repeated in both term and termAccession. Maps to
				FuGE::OntologyIndividual; in MAGE-TAB there is no separate entity to
				model terms.
				<br/>
				Optionally a local controlled vocabulary or ontology can be defined,
				for example to represent 'Codelists' often used in questionaires.
				Note: this is not a InvestigationElement because of the additional
				xref_label and unique constraint.This class defines a single entry
				from an ontology or a controlled vocabulary.
				<br/>
				If it is a simple controlled vocabulary, there may be no formal
				accession for the term. In these cases the local name should be
				repeated in both term and termAccession. If the term has a value,
				the OntologyTerm will have a single DataProperty whose value was the
				value for the property. For instance, for an OntologyIndividual
				based on the MO ontology the attributes might be: The term would be
				what is usually called the local name in the Ontology, for instance
				'Age'; The termAccession could be
				'http://mged.sourceforge.net/ontologies/MGEDOntology.owl#Age' or a
				an arbitrary accession if one exists; The identifier is a unique
				identifier for individuals in the scope of the FuGE instance; The
				inherited name attribute should not be used; The ontologyURI of
				OntologySource could be
				'http://mged.sourceforge.net/ontologies/MGEDOntology.owl". The
				OntologyTerm subclasses are instances of Ontology classes and
				properties, not the actual terms themselves. An OntologyIndividual,
				if based on an existing Ontology, can be considered a statement that
				can be validated against the referenced ontology. The subclasses and
				their associations are based on the Ontology Definition Model,
				ad/2005-04-13, submitted to the OMG as a response to RFP
				ad/2003-03-40, Copyright 2005 DSTC Pty Ltd. Copyright 2005 IBM
				Copyright 2005 Sandpiper Software, Inc under the standard OMG
				license terms. 
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="ontology_entity">File: ontology.txt</h3> 
<p>Contents:<br>  Ontology defines a reference to a an ontology or
				controlled vocabulary from which well-defined and stable (ontology)
				terms can be obtained. Each Ontology should have a unique name, for
				instance: Gene Ontology, Mammalian Phenotype, Human Phenotype
				Ontology, Unified Medical Language System, Medical Subject Headings,
				etc. Also a abbreviation is required, for instance: GO, MP, HPO,
				UMLS, MeSH, etc. Use of existing ontologies/vocabularies is
				recommended to harmonize phenotypic feature and value descriptions.
				But one can also create a 'local' Ontology. The Ontology class maps
				to FuGE::Ontology, MAGE-TAB::TermSourceREF.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontologyaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>A identifier that uniquely identifies the ontology (typically an acronym). E.g. GO, MeSH, HPO.<br></td>
	</tr>
	<tr>
		<td width="150">ontologyuri</td>
		<td width="50">hyperlink</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) A URI that references the location of the ontology.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="molgenisFile_entity">File: molgenisfile.txt</h3> 
<p>Contents:<br> 
				Helper entity to deal with files. Has a decorator to regulate
				storage and coupling to an Entity. Do not make abstract because of
				subtyping. This means the names of the subclasses will be used to
				distinguish MolgenisFiles and place them in the correct folders.
				<br/>
				MS: make it use the &lt;field type="file" property under the hood. 
				<br/>
				MS: where do the mimetypes go? I mean, I don't see the added value
				now.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="runtimeProperty_entity">File: runtimeproperty.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Value.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="publication_entity">File: publication.txt</h3> 
<p>Contents:<br> 

				Publication is part of the Investigation package and is used to
				represent information about one or more publications related to an
				Investigation. The publication need not only be primary publication
				for an Investigation but may also represent other related
				information- though this use is less common. Publications have
				attributes of publications Authors and also DOI and Pubmed
				identifiers (when these are available). These are represented as
				OntologyTerms as in the MAGE-TAB model all 'xrefs' (cross
				references) for ontologies and accession numbers are handled
				generically. An example of a publication is available in an IDF file
				from ArrayExpress is experiment E-MTAB-506
				<a href="ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt">ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt
				</a>
				.
				<br/>
				The FuGE equivalent to Publication is FuGE::Bibliographic Reference.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">pubmedid_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Pubmed ID.
		This xref uses {pubmedid_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">doi_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Publication DOI.
		This xref uses {doi_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">authorlist</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The names of the authors of the publication.<br></td>
	</tr>
	<tr>
		<td width="150">title</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The title of the Publication.<br></td>
	</tr>
	<tr>
		<td width="150">status_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The status of the Publication.
		This xref uses {status_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">year</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The year of the Publication.<br></td>
	</tr>
	<tr>
		<td width="150">journal</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The title of the Journal.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="useCase_entity">File: usecase.txt</h3> 
<p>Contents:<br>  All the use cases send to the server are stored in this
				entity .
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">usecaseid</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>UseCaseId.<br></td>
	</tr>
	<tr>
		<td width="150">usecasename</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>UseCaseName.<br></td>
	</tr>
	<tr>
		<td width="150">searchtype</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>SearchType.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="molgenisEntity_entity">File: molgenisentity.txt</h3> 
<p>Contents:<br> Referenceable catalog of entity names, menus, forms and
				plugins.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Name of the entity.<br></td>
	</tr>
	<tr>
		<td width="150">type_</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Type of the entity.<br></td>
	</tr>
	<tr>
		<td width="150">classname</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Full name of the entity.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column classname should unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (name, type_) should be unique.</td></tr>
</table>
</p>


<h2>org.molgenis.data file types</h2>
<p>This package enables data models to treat part of their
			data model as data matrix. is essential for Entity Attribute Value
			modeling such as used in xgap and pheno.
</p>
<h3 id="observedInference_entity">File: observedinference.txt</h3> 
<p>Contents:<br>  The InferredValue class defines ObservedValues that are
				inferred as result of human or computational post-processing of
				other ObservedValues. For example: hypertensive = yes when mean
				arterial pressure = 135 AND no hypertension affecting medicine is
				taken. The optional inferenceType property enables definition of the
				type of inference. For example 'mean of a lenght': the observable
				feature is 'length' and the inferenceType is 'mean'. Just as with
				regular ObservedValues, the protocol used for this inference can be
				defined via the protocolApplication association that is inherited
				from ObservedValue. The InferredValue class has no direct mapping to
				other models: XGAP would use input/ouput Data; PaGE would use a self
				reference on ObservedValue.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Investigation.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol application that was used to produce this observation. For example a particular patient visit or the application of a microarray or the calculation of a QTL model.
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">feature_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservableFeature that this observation was made on. For example 'probe123'. Can be ommited for 1D data (i.e., a data list)..
		This xref uses {feature_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">target_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservationTarget that this feature was made on. For example 'individual1'. In a correlation matrix this could be also 'probe123'..
		This xref uses {target_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the     ontology definition or 'code' for this value (recommended for non-numeric     values such as codes).
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The value observed.<br></td>
	</tr>
	<tr>
		<td width="150">relation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to other end of the relationship, if any. For example to a 'brother' or from 'sample' to 'derivedSample'..
		This xref uses {relation_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">time</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Time when the value was observed. For example in time series or if feature is time-dependent like 'age'.<br></td>
	</tr>
	<tr>
		<td width="150">endtime</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Time when the value's validity ended.<br></td>
	</tr>
	<tr>
		<td width="150">derivedfrom_id<br></td>
		<td width="50">mref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References to one or more observed values that were used to infer this observation. TODO: needs multicolumn lookup.
		This mref uses {derivedfrom_id} to find related elements in file <a href="#observedValue_entity">observedValue.txt</a> based on unique column {id}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">inferencetype_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the ontology definition for this inference. For example: mean.
		This xref uses {inferencetype_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="dataFile_entity">File: datafile.txt</h3> 
<p>Contents:<br> ObservedFile is to store observations that result in a
				file. Mapping to other models: MAGE-TAB 1.1 has the column
				ArrayDataFile and DerivedArrayDataFile. In order to make the
				MAGE-TAB 1.1. model more generic we have generalized these to
				DataFile and provided named associations to the respective types via
				Scan and Assay. TODO: make this link to MolgenisFile? Or distinguish
				between links and data?
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">uri</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>reference to the location of the file.<br></td>
	</tr>
	<tr>
		<td width="150">format_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>format of the file. Discussion: is this not already solved in MolgenisFile.
		This xref uses {format_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="data_entity">File: data.txt</h3> 
<p>Contents:<br> 
				Data is a data structure to store a homogeneous matrix of
				observedvalues as one unit, that is, all data elements in the set
				have the same type of feature, target and value. For example: an
				expression qtlProfile (observation.feature) for a Panel of mouse
				(observation.target) that consists of a matrix of Probe X marker
				(featureType and targetType respectively). In the user interface we
				expect that this observation can be shown as a bigger set of
				observations but click-able so the user can drill down to the
				underlying matrix.
				<br/>
				Data is also an observationTarget: this allows Data to be referred
				to in an ObservedValue.relation. TODO: describe how this can be used
				to define inputs/outputs for a protocolApplication. This would allow
				us to use it to link 'pheno' to 'cluster' package so that the whole
				provenace can be administrated as part of the observation models.
				<br/>
				This class maps to XGAP.DataMatrix and MAGE-TAB.Data.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">time</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">today</td>
		<td>time when the protocol was applied.<br></td>
	</tr>
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol that is being used..
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">performer_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Performer.
		This mref uses {performer_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">featuretype</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Defines the type of the columns of this data set. Each column refers to a Feature or Subject.<br></td>
	</tr>
	<tr>
		<td width="150">targettype</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Defines the type of the rows of this matrix. Each row refers to a Feature or Subject.<br></td>
	</tr>
	<tr>
		<td width="150">valuetype</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Type of the values of this matrix, either text strings or decimal numbers.<br></td>
	</tr>
	<tr>
		<td width="150">storage</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">Binary</td>
		<td>Tells you how the data elements are stored or should be stored. For example, 'Binary'.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="binaryDataMatrix_entity">File: binarydatamatrix.txt</h3> 
<p>Contents:<br> Binary file backend for a datamatrix. This extension is
				used to deal with the actual source file. Coupled to a matrix with
				source type 'BinaryFile'. This entity is not shown in the interface.
				Discussion: I am not so happy with the need of alternative
				subclasses. Instead you just need a driver.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the datamatrix this binary file belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="cSVDataMatrix_entity">File: csvdatamatrix.txt</h3> 
<p>Contents:<br> CSV file backend for a datamatrix. Convenient to deal
				with the actual source file. Coupled to a matrix with source type
				'CSVFile'. This entity is not shown in the interface.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the datamatrix this CSV file belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="decimalDataElement_entity">File: decimaldataelement.txt</h3> 
<p>Contents:<br>  A DataElement for storing decimal data.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Investigation.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol application that was used to produce this observation. For example a particular patient visit or the application of a microarray or the calculation of a QTL model.
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">feature_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservableFeature that this observation was made on. For example 'probe123'. Can be ommited for 1D data (i.e., a data list)..
		This xref uses {feature_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">target_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservationTarget that this feature was made on. For example 'individual1'. In a correlation matrix this could be also 'probe123'..
		This xref uses {target_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the data set this entity belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">featureindex</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Row position in the matrix.<br></td>
	</tr>
	<tr>
		<td width="150">targetindex</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Col position in the matrix.<br></td>
	</tr>
	<tr>
		<td width="150">value</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The value, e.g., correlation.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (featureindex, targetindex, data) should be unique.</td></tr>
</table>
</p>


<h3 id="textDataElement_entity">File: textdataelement.txt</h3> 
<p>Contents:<br> Store text data
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Investigation.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol application that was used to produce this observation. For example a particular patient visit or the application of a microarray or the calculation of a QTL model.
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">feature_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservableFeature that this observation was made on. For example 'probe123'. Can be ommited for 1D data (i.e., a data list)..
		This xref uses {feature_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">target_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservationTarget that this feature was made on. For example 'individual1'. In a correlation matrix this could be also 'probe123'..
		This xref uses {target_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the data set this entity belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">featureindex</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Row position in the matrix.<br></td>
	</tr>
	<tr>
		<td width="150">targetindex</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Col position in the matrix.<br></td>
	</tr>
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The value, e.g., genotype strings like AA, BA, BB.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (featureindex, targetindex, data) should be unique.</td></tr>
</table>
</p>


<h3 id="originalFile_entity">File: originalfile.txt</h3> 
<p>Contents:<br> An unmodified original file that belongs to this
				datamatrix.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the datamatrix this file belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h2>org.molgenis.organization file types</h2>
<p>Generic entities you can use as the starting point of
			your model.
</p>
<h3 id="investigation_entity">File: investigation.txt</h3> 
<p>Contents:<br> Investigation defines self-contained units of study. For
				example: Framingham study. Optionally a description and an accession
				to a data source can be provided. Each Investigation has a unique
				name and a group of subjects of observation (ObservableTarget),
				traits of observation (ObservableFeature), results (in
				ObservedValues), and optionally actions (Protocols,
				ProtoclApplications). 'Invetigation' maps to standard XGAP/FuGE
				Investigation, MAGE-TAB Experiment and METABASE:Study.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">startdate</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">today</td>
		<td>The start point of the study.<br></td>
	</tr>
	<tr>
		<td width="150">enddate</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The end point of the study.<br></td>
	</tr>
	<tr>
		<td width="150">contacts_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Contact persons for this study.
		This mref uses {contacts_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">accession</td>
		<td width="50">hyperlink</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) URI or accession number to indicate source of Study. E.g. arrayexpress:M-EXP-2345.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h2>org.molgenis.pheno file types</h2>
<p>Pheno is an generic version of XGAP developed in close
			collaboration within GEN2PHEN, EBI, UMC Groningen, U Groningen, FIMM,
			U Leicester. Todo: add docs again from pheno model. The pheno core
			needs to be preserved! Add changelog special section.
		
</p>
<h3 id="species_entity">File: species.txt</h3> 
<p>Contents:<br> Ontology terms for species. E.g. Arabidopsis thaliana.
				DISCUSSION: should we avoid subclasses of OntologyTerm and instead
				make a 'tag' filter on terms so we can make pulldowns context
				dependent (e.g. to only show particular subqueries of ontologies).
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="alternateId_entity">File: alternateid.txt</h3> 
<p>Contents:<br> 
				An external identifier for an annotation. For example: name='R13H8.1', ontology='ensembl' or name='WBgene00000912', ontology='wormbase'.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="observationElement_entity">File: observationelement.txt</h3> 
<p>Contents:<br>  Elements that are the targets or features we are
				looking at of our research.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="observationTarget_entity">File: observationtarget.txt</h3> 
<p>Contents:<br>  An ObservationTarget class defines the subjects of
				observation. For instance: individual 1 from Investigation x. The
				ObservationTarget class maps to XGAP:Subject, METABASE:Patient and
				maps to Page:Abstract_Observation_Target. The name of
				observationTargets is unique.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="observableFeature_entity">File: observablefeature.txt</h3> 
<p>Contents:<br> ObservableFeature defines anything that can be observed
				in a phenotypic Investigation. For instance: Height, Systolic blood
				pressure, Diastolic blood pressure, and Treatment for hypertension
				are observable features. The name of ObservableFeature is unique
				within one Investigation. It is recommended that each
				ObservableFeature is named according to a well-defined ontology term
				which can be specified via ontologyReference. Note that in some
				instances an observableFeature can also be an observationTarget, for
				example in the case of correlation matrices. The ObservableFeature
				class maps to XGAP:Trait, METABASE:Question, FuGE:DimensionElement,
				and PaGE:ObservableFeature. Multi-value features can be grouped by
				Protocol. For instance: high blood pressure can be inferred from
				observations for features systolic and diastolic blood pressure.
				There may be many alternative protocols to measure a feature. See
				Protocol section.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="measurement_entity">File: measurement.txt</h3> 
<p>Contents:<br> Generic obserable feature to flexibly define a
				measurement
			
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Rudimentary meta data about the observable feature. Use of ontology       terms references to establish unambigious descriptions is recommended.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">unit_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the well-defined measurement unit used to observe this feature       (if feature is that concrete). E.g. mmHg.
		This xref uses {unit_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">datatype</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">string</td>
		<td>(Optional) Reference to the technical data type. E.g. 'int'.<br></td>
	</tr>
	<tr>
		<td width="150">temporal</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>Whether this feature is time dependent and can have different values when measured       on different times (e.g. weight, temporal=true) or generally only measured once (e.g. birth date,       temporal=false).<br></td>
	</tr>
	<tr>
		<td width="150">categories_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Translation of codes into categories if applicable.
		This mref uses {categories_name} to find related elements in file <a href="#category_entity">category.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">targettypeallowedforrelation_className<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Subclass of ObservationTarget (Individual, Panel or Location) that      can be linked to (through the 'relation' field in ObservedValue) when using this       Measurement (example: a Measurement 'Species' can only result in ObservedValues       that have relations to Panels).
		This xref uses {targettypeallowedforrelation_classname} to find related elements in file <a href="#molgenisEntity_entity">molgenisEntity.txt</a> based on unique column {classname}.
		</td>
	</tr>	
	<tr>
		<td width="150">panellabelallowedforrelation</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Label that must have been applied to the Panel that      can be linked to (through the 'relation' field in ObservedValue) when using this       Measurement (example: a Measurement 'Species' can only result      in ObservedValues that have relations to Panels labeled as 'Species').<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="category_entity">File: category.txt</h3> 
<p>Contents:<br> Special kind of ObservationElement to define categorical answer codes such as are
				often used in Questionaires. A list of categories can be attached to an
				Measurement using Measurement.categories. For example the
				Measurement 'sex' has {code_string = 1, label=male} and {code_string = 2,
				label=female}. Categories can be linked to well-defined ontology terms
				via the ontologyReference. Category extends ObservationElement such that
				it can be referenced by ObservedValue.value. The Category class maps
				to METABASE::Category
			
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Description of the code.     Use of ontology terms references to establish unambigious descriptions is     recommended.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this code..
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">code_string</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The code used to represent this category. For example: { '1' codes for 'male', '2'-'female'}.<br></td>
	</tr>
	<tr>
		<td width="150">ismissing</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>whether this code should be treated as missing value.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="individual_entity">File: individual.txt</h3> 
<p>Contents:<br>  The Individuals class defines human cases that are used
				as observation target. The Individual class maps to XGAP:Individual
				and PaGE:Individual. Note that minimal information like 'sex' can be
				defined as ObservedValue, and that that basic relationships like
				'father' and 'mother' can also be defined via ObservedRelationship,
				using the 'relation' field. Groups of individuals can be defined via
				Panel.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">mother_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Refers to the mother of the individual..
		This xref uses {mother_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">father_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Refers to the father of the individual..
		This xref uses {father_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="location_entity">File: location.txt</h3> 
<p>Contents:<br> This class defines physical locations such as buildings,
				departments, rooms, freezers and cages. Use ObservedValues to link
				locations to eachother, to build a location hierarchy.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="panel_entity">File: panel.txt</h3> 
<p>Contents:<br> The Panel class defines groups of individuals based on
				cohort design, case/controls, families, etc. For instance: LifeLines
				cohort, 'middle aged man', 'recombinant mouse inbred Line dba x b6'
				or 'Smith family'. A Panel can act as a single ObservationTarget.
				For example: average height (ObservedValue) in the LifeLines cohort
				(Panel) is 174cm. The Panel class maps to XGAP:Strain and PaGE:Panel
				classes. In METABASE this is assumed there is one panel per study.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">individuals_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The list of individuals in this panel.
		This mref uses {individuals_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">species_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The species this panel is an instance of/part of/extracted from..
		This xref uses {species_name} to find related elements in file <a href="#species_entity">species.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">paneltype_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicate the type of Panel (example: Natural=wild type, Parental=parents of a cross, F1=First generation of cross, RCC=Recombinant congenic, CSS=chromosome substitution).
		This xref uses {paneltype_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">founderpanels_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The panel(s) that were used to create this panel..
		This mref uses {founderpanels_name} to find related elements in file <a href="#panel_entity">panel.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="observedValue_entity">File: observedvalue.txt</h3> 
<p>Contents:<br> 
				Generic storage of values, relationships and optional ontology
				mapping of the value/relation. Values can be atomatic observations,
				e.g., length (feature) of individual 1 (target) = 179cm (value).
				Values can also be relationship values, e.g., extract (feature) of
				sample 1 (target) = derived sample (relation).
				<br/>
				Discussion: how to model sample pooling in this model?
				<br/>
				More Discussion: do we want to have type specific subclasses? No,
				because you can solve this by casting during querying?
			
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Investigation.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol application that was used to produce this observation. For example a particular patient visit or the application of a microarray or the calculation of a QTL model.
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">feature_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservableFeature that this observation was made on. For example 'probe123'. Can be ommited for 1D data (i.e., a data list)..
		This xref uses {feature_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">target_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservationTarget that this feature was made on. For example 'individual1'. In a correlation matrix this could be also 'probe123'..
		This xref uses {target_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the     ontology definition or 'code' for this value (recommended for non-numeric     values such as codes).
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The value observed.<br></td>
	</tr>
	<tr>
		<td width="150">relation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to other end of the relationship, if any. For example to a 'brother' or from 'sample' to 'derivedSample'..
		This xref uses {relation_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">time</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Time when the value was observed. For example in time series or if feature is time-dependent like 'age'.<br></td>
	</tr>
	<tr>
		<td width="150">endtime</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Time when the value's validity ended.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h2>org.molgenis.protocol file types</h2>
<p>Molgenis compute framework that extends the molgenis
			protocol framework adding the computational details
		
</p>
<h3 id="protocol_entity">File: protocol.txt</h3> 
<p>Contents:<br> 

				The Protocol class defines parameterizable descriptions of methods;
				each protocol has a unique name within an Study. Each
				ProtocolApplication can define the ObservableFeatures it can
				observe. Also the protocol parameters can be modeled using
				ObservableFeatures (Users are expected to 'tag' the observeable
				feature by setting ObserveableFeature type as 'ProtocolParameter'.
				Examples of protocols are: SOP for blood pressure measurement used
				by UK biobank, or 'R/qtl' as protocol for statistical analysis.
				Protocol is a high level object that represents the details of
				protocols used during the investigation. The uses of Protocols to
				process BioMaterials and Data are referenced by ProtocolApplication
				(in the SDRF part of the format). Protocol has an association to
				OntologyTerm to represent the type of protocol. Protocols are
				associated with Hardware, Software and Parameters used in the
				Protocol. An example from ArrayExpress is E-MTAB-506
				<a href="ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt">
					ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt.
				</a>
    <br/>
				The FUGE equivalent to Protocol is FuGE::Protocol.
				<br/>
				The Protocol class maps to FuGE/XGAP/MageTab Protocol, but in
				contrast to FuGE it is not required to extend protocol before use.
				The Protocol class also maps to METABASE:Form (note that components
				are solved during METABASE:Visit which can be nested). Has no
				equivalent in PaGE.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">richtext</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Description, or reference to a description, of the protocol.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocoltype_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>annotation of the protocol to a well-defined ontological class..
		This xref uses {protocoltype_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">features_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The features that can be observed using this protocol. For example 'length' or 'rs123534' or 'probe123'. Also protocol parameters are considered observable features as they are important to the interpretation of the observed values..
		This mref uses {features_name} to find related elements in file <a href="#observableFeature_entity">observableFeature.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">targetfilter</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Expression that filters the InvestigationElements that can be targetted using this protocol.     This helps the user to only select from targets that matter when setting observedvalues. For example: type='individual' AND species = 'human'.<br></td>
	</tr>
	<tr>
		<td width="150">contact_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>TODO Check if there can be multiple contacts..
		This xref uses {contact_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">subprotocols_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Subprotocols of this protocol.
		This mref uses {subprotocols_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
</table>
</p>


<h3 id="protocolApplication_entity">File: protocolapplication.txt</h3> 
<p>Contents:<br> 
				A ProtocolApplication class defines the actual action of observation
				by refering to a protocol and optional ParameterValues. The name
				field can be used to label applications with a human understandeable
				tag. For example: the action of blood pressure measurement on 1000
				individuals, using a particular protocol, resulting in 1000
				associated observed values. If desired, protocols can be shared
				between Studys; in those cases one should simply refer to a protocol
				in another Study.
				<br/>
				ProtocolApplications are used in MAGE-TAB format to reference to
				protocols used, with optionally use of certain protocol parameter
				values. For example, a Source may be transformed into a Labeled
				Extract by the subsequent application of a Extraction and Labeling
				protocol. ProtocolApplication is associated with and Edge that links
				input/output, e.g. Source to Labeled Extract. The order of the
				application of protocols can be set in order to be able to
				reconstruct the left-to-right order of protocol references in
				MAGE-TAB format. The FuGE equivalent to ProtocolApplication is
				FuGE:ProtocolApplication, however input/output is modeled using
				Edge.
				<br/>
				The ProtocolApplication class maps to FuGE/XGAP ProtocolApplication,
				but in FuGE ProtocolApplications can take Material or Data (or both)
				as input and produce Material or Data (or both) as output. Similar
				to PaGE.ObservationMethod. Maps to METABASE:Visit (also note that
				METABASE:PlannedVisit allows for planning of protocol applications;
				this is outside scope for this model?).
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">time</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">today</td>
		<td>time when the protocol was applied.<br></td>
	</tr>
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol that is being used..
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">performer_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Performer.
		This mref uses {performer_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
</table>
</p>


<h3 id="protocolDocument_entity">File: protocoldocument.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>protocol.
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">document</td>
		<td width="50">file</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>document.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="workflow_entity">File: workflow.txt</h3> 
<p>Contents:<br> A workflow is a plan to execute a series of subprotocols
				in a particular order. Each workflow elements is another protocol as
				refered to via WorkflowElement. Because Workflow extends Protocol,
				workflows can be nested just as any other protocol.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">richtext</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Description, or reference to a description, of the protocol.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocoltype_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>annotation of the protocol to a well-defined ontological class..
		This xref uses {protocoltype_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">features_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The features that can be observed using this protocol. For example 'length' or 'rs123534' or 'probe123'. Also protocol parameters are considered observable features as they are important to the interpretation of the observed values..
		This mref uses {features_name} to find related elements in file <a href="#observableFeature_entity">observableFeature.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">targetfilter</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Expression that filters the InvestigationElements that can be targetted using this protocol.     This helps the user to only select from targets that matter when setting observedvalues. For example: type='individual' AND species = 'human'.<br></td>
	</tr>
	<tr>
		<td width="150">contact_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>TODO Check if there can be multiple contacts..
		This xref uses {contact_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">subprotocols_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Subprotocols of this protocol.
		This mref uses {subprotocols_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="workflowElement_entity">File: workflowelement.txt</h3> 
<p>Contents:<br> Elements of a workflow are references to protocols. The
				whole workflow is a directed graph with each element pointing to the
				previousSteps that the current workflow element depends on.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">workflow_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Workflow this element is part of.
		This xref uses {workflow_name} to find related elements in file <a href="#workflow_entity">workflow.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Protocol to be used at this workflow step.
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">previoussteps_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Previous steps that need to be done before this protocol can be executed..
		This mref uses {previoussteps_name} to find related elements in file <a href="#workflowElement_entity">workflowElement.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="workflowElementParameter_entity">File: workflowelementparameter.txt</h3> 
<p>Contents:<br> Element parameters are the way to link workflow elements
				together. It allows override of the parameters from the previous
				step.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">workflowelement_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>To attach a parameter to a WorkflowElement.
		This xref uses {workflowelement_name} to find related elements in file <a href="#workflowElement_entity">workflowElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">parameter_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Parameter definition..
		This xref uses {parameter_name} to find related elements in file <a href="#observableFeature_entity">observableFeature.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Value of this parameter. Can be a template of form ${other} refering to previous values in context.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (workflowelement, parameter) should be unique.</td></tr>
</table>
</p>


<h2>org.molgenis.xgap file types</h2>
<p>XGAP
</p>
<h3 id="chromosome_entity">File: chromosome.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">ordernr</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>orderNr.<br></td>
	</tr>
	<tr>
		<td width="150">isautosomal</td>
		<td width="50">bool</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Is 'yes' when number of chromosomes is equal in male and female individuals, i.e., if not a sex chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bplength</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Lenght of the chromsome in base pairs.<br></td>
	</tr>
	<tr>
		<td width="150">species_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the species this     chromosome belongs to..
		This xref uses {species_name} to find related elements in file <a href="#species_entity">species.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="nMRBin_entity">File: nmrbin.txt</h3> 
<p>Contents:<br>  Shift of the NMR frequency due to the chemical
				environment.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="clone_entity">File: clone.txt</h3> 
<p>Contents:<br>  BAC clone fragment.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="derivedTrait_entity">File: derivedtrait.txt</h3> 
<p>Contents:<br>  Any meta trait, eg. false discovery rates, P-values,
				thresholds.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="environmentalFactor_entity">File: environmentalfactor.txt</h3> 
<p>Contents:<br> Experimental conditions,
			such as temperature differences, batch effects etc.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="gene_entity">File: gene.txt</h3> 
<p>Contents:<br>  Trait annotations specific for genes.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Main symbol this gene is known by (not necessarily unique, in constrast to 'name').<br></td>
	</tr>
	<tr>
		<td width="150">orientation</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Orientation of the gene on the genome (F=forward, R=reverse).<br></td>
	</tr>
	<tr>
		<td width="150">control</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicating whether this is a 'housekeeping' gene that can be used as control.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="transcript_entity">File: transcript.txt</h3> 
<p>Contents:<br>  Trait annotations specific for transcripts.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">gene_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene that produces this protein.
		This xref uses {gene_name} to find related elements in file <a href="#gene_entity">gene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="protein_entity">File: protein.txt</h3> 
<p>Contents:<br>  Trait annotations specific for proteins.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">gene_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene that produces this protein.
		This xref uses {gene_name} to find related elements in file <a href="#gene_entity">gene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">transcript_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The transcript variant that produces this protein.
		This xref uses {transcript_name} to find related elements in file <a href="#transcript_entity">transcript.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">aminosequence</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The aminoacid sequence.<br></td>
	</tr>
	<tr>
		<td width="150">mass</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The mass of this metabolite.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="metabolite_entity">File: metabolite.txt</h3> 
<p>Contents:<br>  Trait annotations specific for metabolites.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">formula</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The chemical formula of a metabolite.<br></td>
	</tr>
	<tr>
		<td width="150">mass</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The mass of this metabolite.<br></td>
	</tr>
	<tr>
		<td width="150">structure</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The chemical structure of a metabolite (in SMILES representation).<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="marker_entity">File: marker.txt</h3> 
<p>Contents:<br>  Trait annotations specific for markers.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The marker (or a subclass like 'SNP') this marker (or a subclass like 'SNP') reports for..
		This mref uses {reportsfor_name} to find related elements in file <a href="#marker_entity">marker.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="sNP_entity">File: snp.txt</h3> 
<p>Contents:<br> A SNP is a special kind of Marker, but can also be seen as a phenotype to map against in some cases. A single-nucleotide polymorphism is a DNA sequence variation occurring when a single nucleotide in the genome (or other shared sequence) differs between members of a biological species or paired chromosomes in an individual.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The marker (or a subclass like 'SNP') this marker (or a subclass like 'SNP') reports for..
		This mref uses {reportsfor_name} to find related elements in file <a href="#marker_entity">marker.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">status</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The status of this SNP, eg 'confirmed'.<br></td>
	</tr>
	<tr>
		<td width="150">polymorphism_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The polymorphism that belongs to this SNP..
		This mref uses {polymorphism_name} to find related elements in file <a href="#polymorphism_entity">polymorphism.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="polymorphism_entity">File: polymorphism.txt</h3> 
<p>Contents:<br> The difference of a single base discovered between two sequenced individuals.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">base</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The affected DNA base. Note that you can select the reference base here.<br></td>
	</tr>
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The strain/genotype for which this polymorphism was discovered. E.g. 'N2' or 'CB4856'.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="probe_entity">File: probe.txt</h3> 
<p>Contents:<br>  A piece of sequence that reports for the expression of
				a gene, typically spotted onto a microarray.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">mismatch</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>Indicating whether the probe is a match.<br></td>
	</tr>
	<tr>
		<td width="150">probeset_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional: probeset this probe belongs to (e.g., in Affymetrix assays)..
		This xref uses {probeset_name} to find related elements in file <a href="#probeSet_entity">probeSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene this probe reports for..
		This xref uses {reportsfor_name} to find related elements in file <a href="#gene_entity">gene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="spot_entity">File: spot.txt</h3> 
<p>Contents:<br> 
				This is the spot on a microarray.
				<br/>
				Note: We don't distinquish between probes (the sequence) and spots
				(the sequence as spotted on the array).
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">mismatch</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>Indicating whether the probe is a match.<br></td>
	</tr>
	<tr>
		<td width="150">probeset_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional: probeset this probe belongs to (e.g., in Affymetrix assays)..
		This xref uses {probeset_name} to find related elements in file <a href="#probeSet_entity">probeSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene this probe reports for..
		This xref uses {reportsfor_name} to find related elements in file <a href="#gene_entity">gene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">x</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Row.<br></td>
	</tr>
	<tr>
		<td width="150">y</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Column.<br></td>
	</tr>
	<tr>
		<td width="150">gridx</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Meta Row.<br></td>
	</tr>
	<tr>
		<td width="150">gridy</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Meta Column.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (x, y, gridx, gridy) should be unique.</td></tr>
</table>
</p>


<h3 id="probeSet_entity">File: probeset.txt</h3> 
<p>Contents:<br>  A set of Probes. E.g. an Affymetrix probeset has multiple
				probes. It implements locus because sometimes you want to give the complete set of probes a range,
				for example: indicating that this set of probes spans basepair 0 through 10.000.000 on chromosome 3.
				The same information could arguably also be queried from the probes themselves, but if you have 40k probes,
				retrieving the same information from only ProbeSet (if annotated so) would be much faster.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="massPeak_entity">File: masspeak.txt</h3> 
<p>Contents:<br>  A peak that has been selected within a mass
				spectrometry experiment.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">mz</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Mass over charge ratio of this peak.<br></td>
	</tr>
	<tr>
		<td width="150">retentiontime</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The retention-time of this peak in minutes.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="investigationFile_entity">File: investigationfile.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study..
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="tissue_entity">File: tissue.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="sampleLabel_entity">File: samplelabel.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="sample_entity">File: sample.txt</h3> 
<p>Contents:<br> 
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">individual_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The individual from which this sample was taken..
		This xref uses {individual_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">tissue_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The tissue from which this sample was taken..
		This xref uses {tissue_name} to find related elements in file <a href="#tissue_entity">tissue.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="pairedSample_entity">File: pairedsample.txt</h3> 
<p>Contents:<br>  A pair of samples labeled for a two-color microarray
				experiment.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">subject1_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The first subject.
		This xref uses {subject1_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">label1_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Which channel or Fluorescent labeling is associated with the first subject.
		This xref uses {label1_name} to find related elements in file <a href="#sampleLabel_entity">sampleLabel.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">subject2_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The second sample.
		This xref uses {subject2_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">label2_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Which channel or Fluorescent labeling is associated with the second subject.
		This xref uses {label2_name} to find related elements in file <a href="#sampleLabel_entity">sampleLabel.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h2>org.molgenis.cluster file types</h2>
<p>Cluster calculation tables.
</p>
<h3 id="job_entity">File: job.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">outputdataname</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Name of the matrix that will be written.<br></td>
	</tr>
	<tr>
		<td width="150">timestamp</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Datatime when the job was started.<br></td>
	</tr>
	<tr>
		<td width="150">analysis_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Analysis.
		This xref uses {analysis_name} to find related elements in file <a href="#analysis_entity">analysis.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">computeresource</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">local</td>
		<td>ComputeResource.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column outputdataname should unique.</td></tr>
</table>
</p>


<h3 id="subjob_entity">File: subjob.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">job_OutputDataName<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the job this subjob belongs to..
		This xref uses {job_outputdataname} to find related elements in file <a href="#job_entity">job.txt</a> based on unique column {outputdataname}.
		</td>
	</tr>	
	<tr>
		<td width="150">statuscode</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Status code of this subjob.<br></td>
	</tr>
	<tr>
		<td width="150">statustext</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Status text of this subjob.<br></td>
	</tr>
	<tr>
		<td width="150">statusprogress</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Percentage done.<br></td>
	</tr>
	<tr>
		<td width="150">nr</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Number of this subjob within the job.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="analysis_entity">File: analysis.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional description of this type of analysis.<br></td>
	</tr>
	<tr>
		<td width="150">parameterset_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>ParameterSet.
		This xref uses {parameterset_name} to find related elements in file <a href="#parameterSet_entity">parameterSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">dataset_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>DataSet.
		This xref uses {dataset_name} to find related elements in file <a href="#dataSet_entity">dataSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">targetfunctionname</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The function used to start a specific type of analysis on the cluster.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="parameterSet_entity">File: parameterset.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="parameterName_entity">File: parametername.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">parameterset_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>ParameterSet.
		This xref uses {parameterset_name} to find related elements in file <a href="#parameterSet_entity">parameterSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional description of this parameter.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, parameterset) should be unique.</td></tr>
</table>
</p>


<h3 id="parameterValue_entity">File: parametervalue.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">parametername_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>ParameterName.
		This xref uses {parametername_name} to find related elements in file <a href="#parameterName_entity">parameterName.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Possible value of this parameter.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, parametername) should be unique.</td></tr>
</table>
</p>


<h3 id="dataSet_entity">File: dataset.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="dataName_entity">File: dataname.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">dataset_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>DataSet.
		This xref uses {dataset_name} to find related elements in file <a href="#dataSet_entity">dataSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, dataset) should be unique.</td></tr>
</table>
</p>


<h3 id="dataValue_entity">File: datavalue.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">dataname_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>DataName.
		This xref uses {dataname_name} to find related elements in file <a href="#dataName_entity">dataName.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Possible reference of this Data..
		This xref uses {value_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, dataname) should be unique.</td></tr>
</table>
</p>


<h3 id="selectedParameter_entity">File: selectedparameter.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">job_OutputDataName<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Job.
		This xref uses {job_outputdataname} to find related elements in file <a href="#job_entity">job.txt</a> based on unique column {outputdataname}.
		</td>
	</tr>	
	<tr>
		<td width="150">parametername</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Copied name of this parameter.<br></td>
	</tr>
	<tr>
		<td width="150">parametervalue</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Copied value of this parameter.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="selectedData_entity">File: selecteddata.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">job_OutputDataName<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Job.
		This xref uses {job_outputdataname} to find related elements in file <a href="#job_entity">job.txt</a> based on unique column {outputdataname}.
		</td>
	</tr>	
	<tr>
		<td width="150">dataname</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Copied name of this Data.<br></td>
	</tr>
	<tr>
		<td width="150">datavalue</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Copied referenced name of this Data.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="rScript_entity">File: rscript.txt</h3> 
<p>Contents:<br> 
			Proof of concept to show users can add scripts to database, to be replaced later with more generic version from compute model.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study..
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h2>org.molgenis.hemodb file types</h2>

<h3 id="hemoSample_entity">File: hemosample.txt</h3> 
<p>Contents:<br> 
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Illumina internal ID.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">platform</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Illumina Platform.<br></td>
	</tr>
	<tr>
		<td width="150">rna_amplification</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Method of amplification (Magnetic or Column).<br></td>
	</tr>
	<tr>
		<td width="150">sample</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>UMCG sample ID.<br></td>
	</tr>
	<tr>
		<td width="150">expr_cd34</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Expression of CD34, plus = expressed, minus = not expressed.<br></td>
	</tr>
	<tr>
		<td width="150">aml_normal</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Sample type.<br></td>
	</tr>
	<tr>
		<td width="150">samplegroup_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>SampleGroup.
		This xref uses {samplegroup_name} to find related elements in file <a href="#hemoSampleGroup_entity">hemoSampleGroup.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">age</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>NA, old, young, fetal, numerical.<br></td>
	</tr>
	<tr>
		<td width="150">fab</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>French-American-British classification system of hematologic diseases.<br></td>
	</tr>
	<tr>
		<td width="150">risk</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Risk group (Poor, intermediate, good).<br></td>
	</tr>
	<tr>
		<td width="150">flt3_class</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Classification based on the FLT3 gene (ITD,NA,normal,WT).<br></td>
	</tr>
	<tr>
		<td width="150">npm</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Classification based on NPM (cyt,NA,not determined,wt).<br></td>
	</tr>
	<tr>
		<td width="150">procent_cd34</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Percentage of CD34.<br></td>
	</tr>
	<tr>
		<td width="150">pb_bm_cb</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Sample origin (peripheral blood, bone marrow or cord blood).<br></td>
	</tr>
	<tr>
		<td width="150">age_years</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Age in years.<br></td>
	</tr>
	<tr>
		<td width="150">cytogenetics</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Cytogenetics (where NK = Normal Karyotype).<br></td>
	</tr>
	<tr>
		<td width="150">os_months</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Overall survival.<br></td>
	</tr>
	<tr>
		<td width="150">efs_months</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Event free survival.<br></td>
	</tr>
	<tr>
		<td width="150">cr</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Complete remission.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="hemoGene_entity">File: hemogene.txt</h3> 
<p>Contents:<br>  Trait annotations specific for genes.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Main symbol this gene is known by (not necessarily unique, in constrast to 'name').<br></td>
	</tr>
	<tr>
		<td width="150">control</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicating whether this is a 'housekeeping' gene that can be used as control.<br></td>
	</tr>
	<tr>
		<td width="150">orientation</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Orientation of the gene on the genome (F=forward, R=reverse).<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="hemoProbe_entity">File: hemoprobe.txt</h3> 
<p>Contents:<br>  A piece of sequence that reports for the expression of
				a gene, typically spotted onto a microarray.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">probeset_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional: probeset this probe belongs to (e.g., in Affymetrix assays)..
		This xref uses {probeset_name} to find related elements in file <a href="#probeSet_entity">probeSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene this probe reports for..
		This xref uses {reportsfor_name} to find related elements in file <a href="#hemoGene_entity">hemoGene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">entrezid</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The entrez ID for the probe.<br></td>
	</tr>
	<tr>
		<td width="150">refseqid</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The refseq ID for the probe.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="hemoSampleGroup_entity">File: hemosamplegroup.txt</h3> 
<p>Contents:<br> Sample classification (ALL CD34+, AML CD34-, AML CD34+, AML MNC, BC CML, BM CD34+, BM post ASCT, BM retroviral model, CB CD34+, CB retroviral model, mob PBSC, NA, NSG, stroma)
			
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>



<!-- entities outside modules -->
<h2>hemodb file types</h2>
<h3 id="molgenisRole_entity">File: molgenisrole.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="molgenisGroup_entity">File: molgenisgroup.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="molgenisRoleGroupLink_entity">File: molgenisrolegrouplink.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">group__name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>group_.
		This xref uses {group__name} to find related elements in file <a href="#molgenisGroup_entity">molgenisGroup.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">role__name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>role_.
		This xref uses {role__name} to find related elements in file <a href="#molgenisRole_entity">molgenisRole.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="person_entity">File: person.txt</h3> 
<p>Contents:<br> 

				Person represents one or more people involved with an Investigation.
				This may include authors on a paper, lab personnel or PIs. Person
				has last name, firstname, mid initial, address, contact and email. A
				Person role is included to represent how a Person is involved with
				an investigation. For submission to repository purposes an allowed
				value is 'submitter' and the term is present in the MGED Ontology,
				an alternative use could represent job title. An Example from
				ArrayExpress is E-MTAB-506
				<a href="ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt">
					ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt.
				</a>
				.
				<br/>
				The FUGE equivalent to Person is FuGE::Person.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<tr>
		<td width="150">address</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">phone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The telephone number of the Contact including the suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">email</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The email address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">fax</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The fax number of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">tollfreephone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>A toll free phone number for the Contact, including suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">city</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. City of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">country</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Country of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">firstname</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>First Name.<br></td>
	</tr>
	<tr>
		<td width="150">midinitials</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Mid Initials.<br></td>
	</tr>
	<tr>
		<td width="150">lastname</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Last Name.<br></td>
	</tr>
	<tr>
		<td width="150">title</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>An academic title, e.g. Prof.dr, PhD.<br></td>
	</tr>
	<tr>
		<td width="150">affiliation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Affiliation.
		This xref uses {affiliation_name} to find related elements in file <a href="#institute_entity">institute.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">department</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Department of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">roles_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicate role of the contact, e.g. lab worker or PI. Changed from mref to xref in oct 2011..
		This xref uses {roles_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (firstname, midinitials, lastname) should be unique.</td></tr>
</table>
</p>


<h3 id="institute_entity">File: institute.txt</h3> 
<p>Contents:<br>  A contact is either a person or an organization. Copied
				from FuGE::Contact.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">address</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">phone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The telephone number of the Contact including the suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">email</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The email address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">fax</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The fax number of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">tollfreephone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>A toll free phone number for the Contact, including suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">city</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. City of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">country</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Country of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="molgenisUser_entity">File: molgenisuser.txt</h3> 
<p>Contents:<br> Anyone who can login
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<tr>
		<td width="150">address</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">phone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The telephone number of the Contact including the suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">email</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The email address of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">fax</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The fax number of the Contact.<br></td>
	</tr>
	<tr>
		<td width="150">tollfreephone</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>A toll free phone number for the Contact, including suitable area codes.<br></td>
	</tr>
	<tr>
		<td width="150">city</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. City of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">country</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Country of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">firstname</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>First Name.<br></td>
	</tr>
	<tr>
		<td width="150">midinitials</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Mid Initials.<br></td>
	</tr>
	<tr>
		<td width="150">lastname</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Last Name.<br></td>
	</tr>
	<tr>
		<td width="150">title</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>An academic title, e.g. Prof.dr, PhD.<br></td>
	</tr>
	<tr>
		<td width="150">affiliation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Affiliation.
		This xref uses {affiliation_name} to find related elements in file <a href="#institute_entity">institute.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">department</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Added from the old definition of MolgenisUser. Department of this contact.<br></td>
	</tr>
	<tr>
		<td width="150">roles_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicate role of the contact, e.g. lab worker or PI. Changed from mref to xref in oct 2011..
		This xref uses {roles_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">password_</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">secret</td>
		<td>big fixme: password type.<br></td>
	</tr>
	<tr>
		<td width="150">activationcode</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Used as alternative authentication mechanism to verify user email and/or if user has lost password.<br></td>
	</tr>
	<tr>
		<td width="150">active</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>Boolean to indicate if this account can be used to login.<br></td>
	</tr>
	<tr>
		<td width="150">superuser</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>superuser.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (firstname, midinitials, lastname) should be unique.</td></tr>
</table>
</p>


<h3 id="molgenisPermission_entity">File: molgenispermission.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">role__name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>role_.
		This xref uses {role__name} to find related elements in file <a href="#molgenisRole_entity">molgenisRole.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">entity_className<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>entity.
		This xref uses {entity_classname} to find related elements in file <a href="#molgenisEntity_entity">molgenisEntity.txt</a> based on unique column {classname}.
		</td>
	</tr>	
	<tr>
		<td width="150">permission</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>permission.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="ontologyTerm_entity">File: ontologyterm.txt</h3> 
<p>Contents:<br> 
				OntologyTerm defines a single entry (term) from an ontology or a
				controlled vocabulary (defined by Ontology). The name is the
				ontology term which is unique within an ontology source, such as
				[examples here]. Other data entities can reference to this
				OntologyTerm to harmonize naming of concepts. Each term should have
				a local, unique label within the Investigation. If no suitable
				ontology term exists then one can define new terms locally (in which
				case there is no formal accession for the term limiting its use for
				cross-Investigation queries). In those cases the local name should
				be repeated in both term and termAccession. Maps to
				FuGE::OntologyIndividual; in MAGE-TAB there is no separate entity to
				model terms.
				<br/>
				Optionally a local controlled vocabulary or ontology can be defined,
				for example to represent 'Codelists' often used in questionaires.
				Note: this is not a InvestigationElement because of the additional
				xref_label and unique constraint.This class defines a single entry
				from an ontology or a controlled vocabulary.
				<br/>
				If it is a simple controlled vocabulary, there may be no formal
				accession for the term. In these cases the local name should be
				repeated in both term and termAccession. If the term has a value,
				the OntologyTerm will have a single DataProperty whose value was the
				value for the property. For instance, for an OntologyIndividual
				based on the MO ontology the attributes might be: The term would be
				what is usually called the local name in the Ontology, for instance
				'Age'; The termAccession could be
				'http://mged.sourceforge.net/ontologies/MGEDOntology.owl#Age' or a
				an arbitrary accession if one exists; The identifier is a unique
				identifier for individuals in the scope of the FuGE instance; The
				inherited name attribute should not be used; The ontologyURI of
				OntologySource could be
				'http://mged.sourceforge.net/ontologies/MGEDOntology.owl". The
				OntologyTerm subclasses are instances of Ontology classes and
				properties, not the actual terms themselves. An OntologyIndividual,
				if based on an existing Ontology, can be considered a statement that
				can be validated against the referenced ontology. The subclasses and
				their associations are based on the Ontology Definition Model,
				ad/2005-04-13, submitted to the OMG as a response to RFP
				ad/2003-03-40, Copyright 2005 DSTC Pty Ltd. Copyright 2005 IBM
				Copyright 2005 Sandpiper Software, Inc under the standard OMG
				license terms. 
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="ontology_entity">File: ontology.txt</h3> 
<p>Contents:<br>  Ontology defines a reference to a an ontology or
				controlled vocabulary from which well-defined and stable (ontology)
				terms can be obtained. Each Ontology should have a unique name, for
				instance: Gene Ontology, Mammalian Phenotype, Human Phenotype
				Ontology, Unified Medical Language System, Medical Subject Headings,
				etc. Also a abbreviation is required, for instance: GO, MP, HPO,
				UMLS, MeSH, etc. Use of existing ontologies/vocabularies is
				recommended to harmonize phenotypic feature and value descriptions.
				But one can also create a 'local' Ontology. The Ontology class maps
				to FuGE::Ontology, MAGE-TAB::TermSourceREF.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontologyaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>A identifier that uniquely identifies the ontology (typically an acronym). E.g. GO, MeSH, HPO.<br></td>
	</tr>
	<tr>
		<td width="150">ontologyuri</td>
		<td width="50">hyperlink</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) A URI that references the location of the ontology.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="molgenisFile_entity">File: molgenisfile.txt</h3> 
<p>Contents:<br> 
				Helper entity to deal with files. Has a decorator to regulate
				storage and coupling to an Entity. Do not make abstract because of
				subtyping. This means the names of the subclasses will be used to
				distinguish MolgenisFiles and place them in the correct folders.
				<br/>
				MS: make it use the &lt;field type="file" property under the hood. 
				<br/>
				MS: where do the mimetypes go? I mean, I don't see the added value
				now.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="runtimeProperty_entity">File: runtimeproperty.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Value.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="publication_entity">File: publication.txt</h3> 
<p>Contents:<br> 

				Publication is part of the Investigation package and is used to
				represent information about one or more publications related to an
				Investigation. The publication need not only be primary publication
				for an Investigation but may also represent other related
				information- though this use is less common. Publications have
				attributes of publications Authors and also DOI and Pubmed
				identifiers (when these are available). These are represented as
				OntologyTerms as in the MAGE-TAB model all 'xrefs' (cross
				references) for ontologies and accession numbers are handled
				generically. An example of a publication is available in an IDF file
				from ArrayExpress is experiment E-MTAB-506
				<a href="ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt">ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt
				</a>
				.
				<br/>
				The FuGE equivalent to Publication is FuGE::Bibliographic Reference.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">pubmedid_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Pubmed ID.
		This xref uses {pubmedid_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">doi_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Publication DOI.
		This xref uses {doi_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">authorlist</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The names of the authors of the publication.<br></td>
	</tr>
	<tr>
		<td width="150">title</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The title of the Publication.<br></td>
	</tr>
	<tr>
		<td width="150">status_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The status of the Publication.
		This xref uses {status_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">year</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The year of the Publication.<br></td>
	</tr>
	<tr>
		<td width="150">journal</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The title of the Journal.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="useCase_entity">File: usecase.txt</h3> 
<p>Contents:<br>  All the use cases send to the server are stored in this
				entity .
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">usecaseid</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>UseCaseId.<br></td>
	</tr>
	<tr>
		<td width="150">usecasename</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>UseCaseName.<br></td>
	</tr>
	<tr>
		<td width="150">searchtype</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>SearchType.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="molgenisEntity_entity">File: molgenisentity.txt</h3> 
<p>Contents:<br> Referenceable catalog of entity names, menus, forms and
				plugins.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Name of the entity.<br></td>
	</tr>
	<tr>
		<td width="150">type_</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Type of the entity.<br></td>
	</tr>
	<tr>
		<td width="150">classname</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Full name of the entity.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column classname should unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (name, type_) should be unique.</td></tr>
</table>
</p>


<h3 id="observedInference_entity">File: observedinference.txt</h3> 
<p>Contents:<br>  The InferredValue class defines ObservedValues that are
				inferred as result of human or computational post-processing of
				other ObservedValues. For example: hypertensive = yes when mean
				arterial pressure = 135 AND no hypertension affecting medicine is
				taken. The optional inferenceType property enables definition of the
				type of inference. For example 'mean of a lenght': the observable
				feature is 'length' and the inferenceType is 'mean'. Just as with
				regular ObservedValues, the protocol used for this inference can be
				defined via the protocolApplication association that is inherited
				from ObservedValue. The InferredValue class has no direct mapping to
				other models: XGAP would use input/ouput Data; PaGE would use a self
				reference on ObservedValue.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Investigation.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol application that was used to produce this observation. For example a particular patient visit or the application of a microarray or the calculation of a QTL model.
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">feature_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservableFeature that this observation was made on. For example 'probe123'. Can be ommited for 1D data (i.e., a data list)..
		This xref uses {feature_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">target_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservationTarget that this feature was made on. For example 'individual1'. In a correlation matrix this could be also 'probe123'..
		This xref uses {target_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the     ontology definition or 'code' for this value (recommended for non-numeric     values such as codes).
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The value observed.<br></td>
	</tr>
	<tr>
		<td width="150">relation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to other end of the relationship, if any. For example to a 'brother' or from 'sample' to 'derivedSample'..
		This xref uses {relation_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">time</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Time when the value was observed. For example in time series or if feature is time-dependent like 'age'.<br></td>
	</tr>
	<tr>
		<td width="150">endtime</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Time when the value's validity ended.<br></td>
	</tr>
	<tr>
		<td width="150">derivedfrom_id<br></td>
		<td width="50">mref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References to one or more observed values that were used to infer this observation. TODO: needs multicolumn lookup.
		This mref uses {derivedfrom_id} to find related elements in file <a href="#observedValue_entity">observedValue.txt</a> based on unique column {id}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">inferencetype_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the ontology definition for this inference. For example: mean.
		This xref uses {inferencetype_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="dataFile_entity">File: datafile.txt</h3> 
<p>Contents:<br> ObservedFile is to store observations that result in a
				file. Mapping to other models: MAGE-TAB 1.1 has the column
				ArrayDataFile and DerivedArrayDataFile. In order to make the
				MAGE-TAB 1.1. model more generic we have generalized these to
				DataFile and provided named associations to the respective types via
				Scan and Assay. TODO: make this link to MolgenisFile? Or distinguish
				between links and data?
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">uri</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>reference to the location of the file.<br></td>
	</tr>
	<tr>
		<td width="150">format_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>format of the file. Discussion: is this not already solved in MolgenisFile.
		This xref uses {format_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="data_entity">File: data.txt</h3> 
<p>Contents:<br> 
				Data is a data structure to store a homogeneous matrix of
				observedvalues as one unit, that is, all data elements in the set
				have the same type of feature, target and value. For example: an
				expression qtlProfile (observation.feature) for a Panel of mouse
				(observation.target) that consists of a matrix of Probe X marker
				(featureType and targetType respectively). In the user interface we
				expect that this observation can be shown as a bigger set of
				observations but click-able so the user can drill down to the
				underlying matrix.
				<br/>
				Data is also an observationTarget: this allows Data to be referred
				to in an ObservedValue.relation. TODO: describe how this can be used
				to define inputs/outputs for a protocolApplication. This would allow
				us to use it to link 'pheno' to 'cluster' package so that the whole
				provenace can be administrated as part of the observation models.
				<br/>
				This class maps to XGAP.DataMatrix and MAGE-TAB.Data.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">time</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">today</td>
		<td>time when the protocol was applied.<br></td>
	</tr>
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol that is being used..
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">performer_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Performer.
		This mref uses {performer_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">featuretype</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Defines the type of the columns of this data set. Each column refers to a Feature or Subject.<br></td>
	</tr>
	<tr>
		<td width="150">targettype</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Defines the type of the rows of this matrix. Each row refers to a Feature or Subject.<br></td>
	</tr>
	<tr>
		<td width="150">valuetype</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Type of the values of this matrix, either text strings or decimal numbers.<br></td>
	</tr>
	<tr>
		<td width="150">storage</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">Binary</td>
		<td>Tells you how the data elements are stored or should be stored. For example, 'Binary'.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="binaryDataMatrix_entity">File: binarydatamatrix.txt</h3> 
<p>Contents:<br> Binary file backend for a datamatrix. This extension is
				used to deal with the actual source file. Coupled to a matrix with
				source type 'BinaryFile'. This entity is not shown in the interface.
				Discussion: I am not so happy with the need of alternative
				subclasses. Instead you just need a driver.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the datamatrix this binary file belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="cSVDataMatrix_entity">File: csvdatamatrix.txt</h3> 
<p>Contents:<br> CSV file backend for a datamatrix. Convenient to deal
				with the actual source file. Coupled to a matrix with source type
				'CSVFile'. This entity is not shown in the interface.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the datamatrix this CSV file belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="decimalDataElement_entity">File: decimaldataelement.txt</h3> 
<p>Contents:<br>  A DataElement for storing decimal data.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Investigation.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol application that was used to produce this observation. For example a particular patient visit or the application of a microarray or the calculation of a QTL model.
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">feature_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservableFeature that this observation was made on. For example 'probe123'. Can be ommited for 1D data (i.e., a data list)..
		This xref uses {feature_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">target_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservationTarget that this feature was made on. For example 'individual1'. In a correlation matrix this could be also 'probe123'..
		This xref uses {target_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the data set this entity belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">featureindex</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Row position in the matrix.<br></td>
	</tr>
	<tr>
		<td width="150">targetindex</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Col position in the matrix.<br></td>
	</tr>
	<tr>
		<td width="150">value</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The value, e.g., correlation.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (featureindex, targetindex, data) should be unique.</td></tr>
</table>
</p>


<h3 id="textDataElement_entity">File: textdataelement.txt</h3> 
<p>Contents:<br> Store text data
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Investigation.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol application that was used to produce this observation. For example a particular patient visit or the application of a microarray or the calculation of a QTL model.
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">feature_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservableFeature that this observation was made on. For example 'probe123'. Can be ommited for 1D data (i.e., a data list)..
		This xref uses {feature_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">target_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservationTarget that this feature was made on. For example 'individual1'. In a correlation matrix this could be also 'probe123'..
		This xref uses {target_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the data set this entity belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">featureindex</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Row position in the matrix.<br></td>
	</tr>
	<tr>
		<td width="150">targetindex</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Col position in the matrix.<br></td>
	</tr>
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The value, e.g., genotype strings like AA, BA, BB.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (featureindex, targetindex, data) should be unique.</td></tr>
</table>
</p>


<h3 id="originalFile_entity">File: originalfile.txt</h3> 
<p>Contents:<br> An unmodified original file that belongs to this
				datamatrix.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">data_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the datamatrix this file belongs to..
		This xref uses {data_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="investigation_entity">File: investigation.txt</h3> 
<p>Contents:<br> Investigation defines self-contained units of study. For
				example: Framingham study. Optionally a description and an accession
				to a data source can be provided. Each Investigation has a unique
				name and a group of subjects of observation (ObservableTarget),
				traits of observation (ObservableFeature), results (in
				ObservedValues), and optionally actions (Protocols,
				ProtoclApplications). 'Invetigation' maps to standard XGAP/FuGE
				Investigation, MAGE-TAB Experiment and METABASE:Study.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">startdate</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">today</td>
		<td>The start point of the study.<br></td>
	</tr>
	<tr>
		<td width="150">enddate</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The end point of the study.<br></td>
	</tr>
	<tr>
		<td width="150">contacts_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Contact persons for this study.
		This mref uses {contacts_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">accession</td>
		<td width="50">hyperlink</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) URI or accession number to indicate source of Study. E.g. arrayexpress:M-EXP-2345.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="species_entity">File: species.txt</h3> 
<p>Contents:<br> Ontology terms for species. E.g. Arabidopsis thaliana.
				DISCUSSION: should we avoid subclasses of OntologyTerm and instead
				make a 'tag' filter on terms so we can make pulldowns context
				dependent (e.g. to only show particular subqueries of ontologies).
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="alternateId_entity">File: alternateid.txt</h3> 
<p>Contents:<br> 
				An external identifier for an annotation. For example: name='R13H8.1', ontology='ensembl' or name='WBgene00000912', ontology='wormbase'.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="observationElement_entity">File: observationelement.txt</h3> 
<p>Contents:<br>  Elements that are the targets or features we are
				looking at of our research.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="observationTarget_entity">File: observationtarget.txt</h3> 
<p>Contents:<br>  An ObservationTarget class defines the subjects of
				observation. For instance: individual 1 from Investigation x. The
				ObservationTarget class maps to XGAP:Subject, METABASE:Patient and
				maps to Page:Abstract_Observation_Target. The name of
				observationTargets is unique.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="observableFeature_entity">File: observablefeature.txt</h3> 
<p>Contents:<br> ObservableFeature defines anything that can be observed
				in a phenotypic Investigation. For instance: Height, Systolic blood
				pressure, Diastolic blood pressure, and Treatment for hypertension
				are observable features. The name of ObservableFeature is unique
				within one Investigation. It is recommended that each
				ObservableFeature is named according to a well-defined ontology term
				which can be specified via ontologyReference. Note that in some
				instances an observableFeature can also be an observationTarget, for
				example in the case of correlation matrices. The ObservableFeature
				class maps to XGAP:Trait, METABASE:Question, FuGE:DimensionElement,
				and PaGE:ObservableFeature. Multi-value features can be grouped by
				Protocol. For instance: high blood pressure can be inferred from
				observations for features systolic and diastolic blood pressure.
				There may be many alternative protocols to measure a feature. See
				Protocol section.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="measurement_entity">File: measurement.txt</h3> 
<p>Contents:<br> Generic obserable feature to flexibly define a
				measurement
			
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Rudimentary meta data about the observable feature. Use of ontology       terms references to establish unambigious descriptions is recommended.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">unit_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the well-defined measurement unit used to observe this feature       (if feature is that concrete). E.g. mmHg.
		This xref uses {unit_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">datatype</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">string</td>
		<td>(Optional) Reference to the technical data type. E.g. 'int'.<br></td>
	</tr>
	<tr>
		<td width="150">temporal</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>Whether this feature is time dependent and can have different values when measured       on different times (e.g. weight, temporal=true) or generally only measured once (e.g. birth date,       temporal=false).<br></td>
	</tr>
	<tr>
		<td width="150">categories_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Translation of codes into categories if applicable.
		This mref uses {categories_name} to find related elements in file <a href="#category_entity">category.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">targettypeallowedforrelation_className<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Subclass of ObservationTarget (Individual, Panel or Location) that      can be linked to (through the 'relation' field in ObservedValue) when using this       Measurement (example: a Measurement 'Species' can only result in ObservedValues       that have relations to Panels).
		This xref uses {targettypeallowedforrelation_classname} to find related elements in file <a href="#molgenisEntity_entity">molgenisEntity.txt</a> based on unique column {classname}.
		</td>
	</tr>	
	<tr>
		<td width="150">panellabelallowedforrelation</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Label that must have been applied to the Panel that      can be linked to (through the 'relation' field in ObservedValue) when using this       Measurement (example: a Measurement 'Species' can only result      in ObservedValues that have relations to Panels labeled as 'Species').<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="category_entity">File: category.txt</h3> 
<p>Contents:<br> Special kind of ObservationElement to define categorical answer codes such as are
				often used in Questionaires. A list of categories can be attached to an
				Measurement using Measurement.categories. For example the
				Measurement 'sex' has {code_string = 1, label=male} and {code_string = 2,
				label=female}. Categories can be linked to well-defined ontology terms
				via the ontologyReference. Category extends ObservationElement such that
				it can be referenced by ObservedValue.value. The Category class maps
				to METABASE::Category
			
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Description of the code.     Use of ontology terms references to establish unambigious descriptions is     recommended.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this code..
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">code_string</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The code used to represent this category. For example: { '1' codes for 'male', '2'-'female'}.<br></td>
	</tr>
	<tr>
		<td width="150">ismissing</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>whether this code should be treated as missing value.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="individual_entity">File: individual.txt</h3> 
<p>Contents:<br>  The Individuals class defines human cases that are used
				as observation target. The Individual class maps to XGAP:Individual
				and PaGE:Individual. Note that minimal information like 'sex' can be
				defined as ObservedValue, and that that basic relationships like
				'father' and 'mother' can also be defined via ObservedRelationship,
				using the 'relation' field. Groups of individuals can be defined via
				Panel.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">mother_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Refers to the mother of the individual..
		This xref uses {mother_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">father_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Refers to the father of the individual..
		This xref uses {father_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="location_entity">File: location.txt</h3> 
<p>Contents:<br> This class defines physical locations such as buildings,
				departments, rooms, freezers and cages. Use ObservedValues to link
				locations to eachother, to build a location hierarchy.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="panel_entity">File: panel.txt</h3> 
<p>Contents:<br> The Panel class defines groups of individuals based on
				cohort design, case/controls, families, etc. For instance: LifeLines
				cohort, 'middle aged man', 'recombinant mouse inbred Line dba x b6'
				or 'Smith family'. A Panel can act as a single ObservationTarget.
				For example: average height (ObservedValue) in the LifeLines cohort
				(Panel) is 174cm. The Panel class maps to XGAP:Strain and PaGE:Panel
				classes. In METABASE this is assumed there is one panel per study.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">individuals_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The list of individuals in this panel.
		This mref uses {individuals_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">species_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The species this panel is an instance of/part of/extracted from..
		This xref uses {species_name} to find related elements in file <a href="#species_entity">species.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">paneltype_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicate the type of Panel (example: Natural=wild type, Parental=parents of a cross, F1=First generation of cross, RCC=Recombinant congenic, CSS=chromosome substitution).
		This xref uses {paneltype_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">founderpanels_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The panel(s) that were used to create this panel..
		This mref uses {founderpanels_name} to find related elements in file <a href="#panel_entity">panel.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="observedValue_entity">File: observedvalue.txt</h3> 
<p>Contents:<br> 
				Generic storage of values, relationships and optional ontology
				mapping of the value/relation. Values can be atomatic observations,
				e.g., length (feature) of individual 1 (target) = 179cm (value).
				Values can also be relationship values, e.g., extract (feature) of
				sample 1 (target) = derived sample (relation).
				<br/>
				Discussion: how to model sample pooling in this model?
				<br/>
				More Discussion: do we want to have type specific subclasses? No,
				because you can solve this by casting during querying?
			
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Investigation.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol application that was used to produce this observation. For example a particular patient visit or the application of a microarray or the calculation of a QTL model.
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">feature_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservableFeature that this observation was made on. For example 'probe123'. Can be ommited for 1D data (i.e., a data list)..
		This xref uses {feature_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">target_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>References the ObservationTarget that this feature was made on. For example 'individual1'. In a correlation matrix this could be also 'probe123'..
		This xref uses {target_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the     ontology definition or 'code' for this value (recommended for non-numeric     values such as codes).
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The value observed.<br></td>
	</tr>
	<tr>
		<td width="150">relation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to other end of the relationship, if any. For example to a 'brother' or from 'sample' to 'derivedSample'..
		This xref uses {relation_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">time</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Time when the value was observed. For example in time series or if feature is time-dependent like 'age'.<br></td>
	</tr>
	<tr>
		<td width="150">endtime</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Time when the value's validity ended.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="protocol_entity">File: protocol.txt</h3> 
<p>Contents:<br> 

				The Protocol class defines parameterizable descriptions of methods;
				each protocol has a unique name within an Study. Each
				ProtocolApplication can define the ObservableFeatures it can
				observe. Also the protocol parameters can be modeled using
				ObservableFeatures (Users are expected to 'tag' the observeable
				feature by setting ObserveableFeature type as 'ProtocolParameter'.
				Examples of protocols are: SOP for blood pressure measurement used
				by UK biobank, or 'R/qtl' as protocol for statistical analysis.
				Protocol is a high level object that represents the details of
				protocols used during the investigation. The uses of Protocols to
				process BioMaterials and Data are referenced by ProtocolApplication
				(in the SDRF part of the format). Protocol has an association to
				OntologyTerm to represent the type of protocol. Protocols are
				associated with Hardware, Software and Parameters used in the
				Protocol. An example from ArrayExpress is E-MTAB-506
				<a href="ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt">
					ftp://ftp.ebi.ac.uk/pub/databases/microarray/data/experiment/TABM/E-TABM-506/E-TABM-506.idf.txt.
				</a>
    <br/>
				The FUGE equivalent to Protocol is FuGE::Protocol.
				<br/>
				The Protocol class maps to FuGE/XGAP/MageTab Protocol, but in
				contrast to FuGE it is not required to extend protocol before use.
				The Protocol class also maps to METABASE:Form (note that components
				are solved during METABASE:Visit which can be nested). Has no
				equivalent in PaGE.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">richtext</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Description, or reference to a description, of the protocol.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocoltype_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>annotation of the protocol to a well-defined ontological class..
		This xref uses {protocoltype_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">features_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The features that can be observed using this protocol. For example 'length' or 'rs123534' or 'probe123'. Also protocol parameters are considered observable features as they are important to the interpretation of the observed values..
		This mref uses {features_name} to find related elements in file <a href="#observableFeature_entity">observableFeature.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">targetfilter</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Expression that filters the InvestigationElements that can be targetted using this protocol.     This helps the user to only select from targets that matter when setting observedvalues. For example: type='individual' AND species = 'human'.<br></td>
	</tr>
	<tr>
		<td width="150">contact_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>TODO Check if there can be multiple contacts..
		This xref uses {contact_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">subprotocols_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Subprotocols of this protocol.
		This mref uses {subprotocols_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
</table>
</p>


<h3 id="protocolApplication_entity">File: protocolapplication.txt</h3> 
<p>Contents:<br> 
				A ProtocolApplication class defines the actual action of observation
				by refering to a protocol and optional ParameterValues. The name
				field can be used to label applications with a human understandeable
				tag. For example: the action of blood pressure measurement on 1000
				individuals, using a particular protocol, resulting in 1000
				associated observed values. If desired, protocols can be shared
				between Studys; in those cases one should simply refer to a protocol
				in another Study.
				<br/>
				ProtocolApplications are used in MAGE-TAB format to reference to
				protocols used, with optionally use of certain protocol parameter
				values. For example, a Source may be transformed into a Labeled
				Extract by the subsequent application of a Extraction and Labeling
				protocol. ProtocolApplication is associated with and Edge that links
				input/output, e.g. Source to Labeled Extract. The order of the
				application of protocols can be set in order to be able to
				reconstruct the left-to-right order of protocol references in
				MAGE-TAB format. The FuGE equivalent to ProtocolApplication is
				FuGE:ProtocolApplication, however input/output is modeled using
				Edge.
				<br/>
				The ProtocolApplication class maps to FuGE/XGAP ProtocolApplication,
				but in FuGE ProtocolApplications can take Material or Data (or both)
				as input and produce Material or Data (or both) as output. Similar
				to PaGE.ObservationMethod. Maps to METABASE:Visit (also note that
				METABASE:PlannedVisit allows for planning of protocol applications;
				this is outside scope for this model?).
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">time</td>
		<td width="50">datetime</td>
		<td width="20">&nbsp;</td>
		<td width="50">today</td>
		<td>time when the protocol was applied.<br></td>
	</tr>
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the protocol that is being used..
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">performer_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Performer.
		This mref uses {performer_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
</table>
</p>


<h3 id="protocolDocument_entity">File: protocoldocument.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>protocol.
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">document</td>
		<td width="50">file</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>document.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="workflow_entity">File: workflow.txt</h3> 
<p>Contents:<br> A workflow is a plan to execute a series of subprotocols
				in a particular order. Each workflow elements is another protocol as
				refered to via WorkflowElement. Because Workflow extends Protocol,
				workflows can be nested just as any other protocol.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">richtext</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Description, or reference to a description, of the protocol.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocoltype_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>annotation of the protocol to a well-defined ontological class..
		This xref uses {protocoltype_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">features_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The features that can be observed using this protocol. For example 'length' or 'rs123534' or 'probe123'. Also protocol parameters are considered observable features as they are important to the interpretation of the observed values..
		This mref uses {features_name} to find related elements in file <a href="#observableFeature_entity">observableFeature.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">targetfilter</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Expression that filters the InvestigationElements that can be targetted using this protocol.     This helps the user to only select from targets that matter when setting observedvalues. For example: type='individual' AND species = 'human'.<br></td>
	</tr>
	<tr>
		<td width="150">contact_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>TODO Check if there can be multiple contacts..
		This xref uses {contact_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">subprotocols_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Subprotocols of this protocol.
		This mref uses {subprotocols_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="workflowElement_entity">File: workflowelement.txt</h3> 
<p>Contents:<br> Elements of a workflow are references to protocols. The
				whole workflow is a directed graph with each element pointing to the
				previousSteps that the current workflow element depends on.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">workflow_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Workflow this element is part of.
		This xref uses {workflow_name} to find related elements in file <a href="#workflow_entity">workflow.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Protocol to be used at this workflow step.
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">previoussteps_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Previous steps that need to be done before this protocol can be executed..
		This mref uses {previoussteps_name} to find related elements in file <a href="#workflowElement_entity">workflowElement.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="workflowElementParameter_entity">File: workflowelementparameter.txt</h3> 
<p>Contents:<br> Element parameters are the way to link workflow elements
				together. It allows override of the parameters from the previous
				step.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">workflowelement_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>To attach a parameter to a WorkflowElement.
		This xref uses {workflowelement_name} to find related elements in file <a href="#workflowElement_entity">workflowElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">parameter_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Parameter definition..
		This xref uses {parameter_name} to find related elements in file <a href="#observableFeature_entity">observableFeature.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Value of this parameter. Can be a template of form ${other} refering to previous values in context.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (workflowelement, parameter) should be unique.</td></tr>
</table>
</p>


<h3 id="chromosome_entity">File: chromosome.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">ordernr</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>orderNr.<br></td>
	</tr>
	<tr>
		<td width="150">isautosomal</td>
		<td width="50">bool</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Is 'yes' when number of chromosomes is equal in male and female individuals, i.e., if not a sex chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bplength</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Lenght of the chromsome in base pairs.<br></td>
	</tr>
	<tr>
		<td width="150">species_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the species this     chromosome belongs to..
		This xref uses {species_name} to find related elements in file <a href="#species_entity">species.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="nMRBin_entity">File: nmrbin.txt</h3> 
<p>Contents:<br>  Shift of the NMR frequency due to the chemical
				environment.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="clone_entity">File: clone.txt</h3> 
<p>Contents:<br>  BAC clone fragment.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="derivedTrait_entity">File: derivedtrait.txt</h3> 
<p>Contents:<br>  Any meta trait, eg. false discovery rates, P-values,
				thresholds.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="environmentalFactor_entity">File: environmentalfactor.txt</h3> 
<p>Contents:<br> Experimental conditions,
			such as temperature differences, batch effects etc.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="gene_entity">File: gene.txt</h3> 
<p>Contents:<br>  Trait annotations specific for genes.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Main symbol this gene is known by (not necessarily unique, in constrast to 'name').<br></td>
	</tr>
	<tr>
		<td width="150">orientation</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Orientation of the gene on the genome (F=forward, R=reverse).<br></td>
	</tr>
	<tr>
		<td width="150">control</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicating whether this is a 'housekeeping' gene that can be used as control.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="transcript_entity">File: transcript.txt</h3> 
<p>Contents:<br>  Trait annotations specific for transcripts.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">gene_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene that produces this protein.
		This xref uses {gene_name} to find related elements in file <a href="#gene_entity">gene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="protein_entity">File: protein.txt</h3> 
<p>Contents:<br>  Trait annotations specific for proteins.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">gene_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene that produces this protein.
		This xref uses {gene_name} to find related elements in file <a href="#gene_entity">gene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">transcript_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The transcript variant that produces this protein.
		This xref uses {transcript_name} to find related elements in file <a href="#transcript_entity">transcript.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">aminosequence</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The aminoacid sequence.<br></td>
	</tr>
	<tr>
		<td width="150">mass</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The mass of this metabolite.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="metabolite_entity">File: metabolite.txt</h3> 
<p>Contents:<br>  Trait annotations specific for metabolites.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">formula</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The chemical formula of a metabolite.<br></td>
	</tr>
	<tr>
		<td width="150">mass</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The mass of this metabolite.<br></td>
	</tr>
	<tr>
		<td width="150">structure</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The chemical structure of a metabolite (in SMILES representation).<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="marker_entity">File: marker.txt</h3> 
<p>Contents:<br>  Trait annotations specific for markers.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The marker (or a subclass like 'SNP') this marker (or a subclass like 'SNP') reports for..
		This mref uses {reportsfor_name} to find related elements in file <a href="#marker_entity">marker.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="sNP_entity">File: snp.txt</h3> 
<p>Contents:<br> A SNP is a special kind of Marker, but can also be seen as a phenotype to map against in some cases. A single-nucleotide polymorphism is a DNA sequence variation occurring when a single nucleotide in the genome (or other shared sequence) differs between members of a biological species or paired chromosomes in an individual.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The marker (or a subclass like 'SNP') this marker (or a subclass like 'SNP') reports for..
		This mref uses {reportsfor_name} to find related elements in file <a href="#marker_entity">marker.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">status</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The status of this SNP, eg 'confirmed'.<br></td>
	</tr>
	<tr>
		<td width="150">polymorphism_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The polymorphism that belongs to this SNP..
		This mref uses {polymorphism_name} to find related elements in file <a href="#polymorphism_entity">polymorphism.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="polymorphism_entity">File: polymorphism.txt</h3> 
<p>Contents:<br> The difference of a single base discovered between two sequenced individuals.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">base</td>
		<td width="50">enum</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The affected DNA base. Note that you can select the reference base here.<br></td>
	</tr>
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The strain/genotype for which this polymorphism was discovered. E.g. 'N2' or 'CB4856'.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="probe_entity">File: probe.txt</h3> 
<p>Contents:<br>  A piece of sequence that reports for the expression of
				a gene, typically spotted onto a microarray.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">mismatch</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>Indicating whether the probe is a match.<br></td>
	</tr>
	<tr>
		<td width="150">probeset_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional: probeset this probe belongs to (e.g., in Affymetrix assays)..
		This xref uses {probeset_name} to find related elements in file <a href="#probeSet_entity">probeSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene this probe reports for..
		This xref uses {reportsfor_name} to find related elements in file <a href="#gene_entity">gene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="spot_entity">File: spot.txt</h3> 
<p>Contents:<br> 
				This is the spot on a microarray.
				<br/>
				Note: We don't distinquish between probes (the sequence) and spots
				(the sequence as spotted on the array).
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">mismatch</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">false</td>
		<td>Indicating whether the probe is a match.<br></td>
	</tr>
	<tr>
		<td width="150">probeset_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional: probeset this probe belongs to (e.g., in Affymetrix assays)..
		This xref uses {probeset_name} to find related elements in file <a href="#probeSet_entity">probeSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene this probe reports for..
		This xref uses {reportsfor_name} to find related elements in file <a href="#gene_entity">gene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">x</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Row.<br></td>
	</tr>
	<tr>
		<td width="150">y</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Column.<br></td>
	</tr>
	<tr>
		<td width="150">gridx</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Meta Row.<br></td>
	</tr>
	<tr>
		<td width="150">gridy</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Meta Column.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (x, y, gridx, gridy) should be unique.</td></tr>
</table>
</p>


<h3 id="probeSet_entity">File: probeset.txt</h3> 
<p>Contents:<br>  A set of Probes. E.g. an Affymetrix probeset has multiple
				probes. It implements locus because sometimes you want to give the complete set of probes a range,
				for example: indicating that this set of probes spans basepair 0 through 10.000.000 on chromosome 3.
				The same information could arguably also be queried from the probes themselves, but if you have 40k probes,
				retrieving the same information from only ProbeSet (if annotated so) would be much faster.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="massPeak_entity">File: masspeak.txt</h3> 
<p>Contents:<br>  A peak that has been selected within a mass
				spectrometry experiment.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">mz</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Mass over charge ratio of this peak.<br></td>
	</tr>
	<tr>
		<td width="150">retentiontime</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The retention-time of this peak in minutes.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="investigationFile_entity">File: investigationfile.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study..
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="tissue_entity">File: tissue.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="sampleLabel_entity">File: samplelabel.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">ontology_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The source ontology or controlled vocabulary list that ontology terms have been obtained from..
		This xref uses {ontology_name} to find related elements in file <a href="#ontology_entity">ontology.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">termaccession</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The accession number assigned to the ontology term in its source ontology. If empty it is assumed to be a locally defined term.<br></td>
	</tr>
	<tr>
		<td width="150">definition</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) The definition of the term.<br></td>
	</tr>
	<tr>
		<td width="150">termpath</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>EXTENSION. The Ontology Lookup Service path that contains this term.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (ontology, termaccession) should be unique.</td></tr>
<tr><td colspan="5">Contraint: values in the combined columns (ontology, name) should be unique.</td></tr>
</table>
</p>


<h3 id="sample_entity">File: sample.txt</h3> 
<p>Contents:<br> 
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">individual_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The individual from which this sample was taken..
		This xref uses {individual_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">tissue_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The tissue from which this sample was taken..
		This xref uses {tissue_name} to find related elements in file <a href="#tissue_entity">tissue.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="pairedSample_entity">File: pairedsample.txt</h3> 
<p>Contents:<br>  A pair of samples labeled for a two-color microarray
				experiment.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">subject1_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The first subject.
		This xref uses {subject1_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">label1_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Which channel or Fluorescent labeling is associated with the first subject.
		This xref uses {label1_name} to find related elements in file <a href="#sampleLabel_entity">sampleLabel.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">subject2_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The second sample.
		This xref uses {subject2_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">label2_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Which channel or Fluorescent labeling is associated with the second subject.
		This xref uses {label2_name} to find related elements in file <a href="#sampleLabel_entity">sampleLabel.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="job_entity">File: job.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">outputdataname</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Name of the matrix that will be written.<br></td>
	</tr>
	<tr>
		<td width="150">timestamp</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Datatime when the job was started.<br></td>
	</tr>
	<tr>
		<td width="150">analysis_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Analysis.
		This xref uses {analysis_name} to find related elements in file <a href="#analysis_entity">analysis.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">computeresource</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">local</td>
		<td>ComputeResource.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column outputdataname should unique.</td></tr>
</table>
</p>


<h3 id="subjob_entity">File: subjob.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">job_OutputDataName<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the job this subjob belongs to..
		This xref uses {job_outputdataname} to find related elements in file <a href="#job_entity">job.txt</a> based on unique column {outputdataname}.
		</td>
	</tr>	
	<tr>
		<td width="150">statuscode</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Status code of this subjob.<br></td>
	</tr>
	<tr>
		<td width="150">statustext</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Status text of this subjob.<br></td>
	</tr>
	<tr>
		<td width="150">statusprogress</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Percentage done.<br></td>
	</tr>
	<tr>
		<td width="150">nr</td>
		<td width="50">int</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Number of this subjob within the job.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="analysis_entity">File: analysis.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional description of this type of analysis.<br></td>
	</tr>
	<tr>
		<td width="150">parameterset_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>ParameterSet.
		This xref uses {parameterset_name} to find related elements in file <a href="#parameterSet_entity">parameterSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">dataset_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>DataSet.
		This xref uses {dataset_name} to find related elements in file <a href="#dataSet_entity">dataSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">targetfunctionname</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The function used to start a specific type of analysis on the cluster.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="parameterSet_entity">File: parameterset.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="parameterName_entity">File: parametername.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">parameterset_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>ParameterSet.
		This xref uses {parameterset_name} to find related elements in file <a href="#parameterSet_entity">parameterSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional description of this parameter.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, parameterset) should be unique.</td></tr>
</table>
</p>


<h3 id="parameterValue_entity">File: parametervalue.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">parametername_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>ParameterName.
		This xref uses {parametername_name} to find related elements in file <a href="#parameterName_entity">parameterName.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Possible value of this parameter.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, parametername) should be unique.</td></tr>
</table>
</p>


<h3 id="dataSet_entity">File: dataset.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="dataName_entity">File: dataname.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">dataset_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>DataSet.
		This xref uses {dataset_name} to find related elements in file <a href="#dataSet_entity">dataSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, dataset) should be unique.</td></tr>
</table>
</p>


<h3 id="dataValue_entity">File: datavalue.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">dataname_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>DataName.
		This xref uses {dataname_name} to find related elements in file <a href="#dataName_entity">dataName.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">value_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Possible reference of this Data..
		This xref uses {value_name} to find related elements in file <a href="#data_entity">data.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, dataname) should be unique.</td></tr>
</table>
</p>


<h3 id="selectedParameter_entity">File: selectedparameter.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">job_OutputDataName<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Job.
		This xref uses {job_outputdataname} to find related elements in file <a href="#job_entity">job.txt</a> based on unique column {outputdataname}.
		</td>
	</tr>	
	<tr>
		<td width="150">parametername</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Copied name of this parameter.<br></td>
	</tr>
	<tr>
		<td width="150">parametervalue</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Copied value of this parameter.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="selectedData_entity">File: selecteddata.txt</h3> 

<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">job_OutputDataName<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Job.
		This xref uses {job_outputdataname} to find related elements in file <a href="#job_entity">job.txt</a> based on unique column {outputdataname}.
		</td>
	</tr>	
	<tr>
		<td width="150">dataname</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Copied name of this Data.<br></td>
	</tr>
	<tr>
		<td width="150">datavalue</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Copied referenced name of this Data.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="rScript_entity">File: rscript.txt</h3> 
<p>Contents:<br> 
			Proof of concept to show users can add scripts to database, to be replaced later with more generic version from compute model.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">extension</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>The file extension. This will be mapped to MIME type at runtime. For example, a type 'png' will be served out as 'image/png'.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study..
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
</table>
</p>


<h3 id="hemoSample_entity">File: hemosample.txt</h3> 
<p>Contents:<br> 
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>Illumina internal ID.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">platform</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Illumina Platform.<br></td>
	</tr>
	<tr>
		<td width="150">rna_amplification</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Method of amplification (Magnetic or Column).<br></td>
	</tr>
	<tr>
		<td width="150">sample</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>UMCG sample ID.<br></td>
	</tr>
	<tr>
		<td width="150">expr_cd34</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Expression of CD34, plus = expressed, minus = not expressed.<br></td>
	</tr>
	<tr>
		<td width="150">aml_normal</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Sample type.<br></td>
	</tr>
	<tr>
		<td width="150">samplegroup_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>SampleGroup.
		This xref uses {samplegroup_name} to find related elements in file <a href="#hemoSampleGroup_entity">hemoSampleGroup.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">age</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>NA, old, young, fetal, numerical.<br></td>
	</tr>
	<tr>
		<td width="150">fab</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>French-American-British classification system of hematologic diseases.<br></td>
	</tr>
	<tr>
		<td width="150">risk</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Risk group (Poor, intermediate, good).<br></td>
	</tr>
	<tr>
		<td width="150">flt3_class</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Classification based on the FLT3 gene (ITD,NA,normal,WT).<br></td>
	</tr>
	<tr>
		<td width="150">npm</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Classification based on NPM (cyt,NA,not determined,wt).<br></td>
	</tr>
	<tr>
		<td width="150">procent_cd34</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Percentage of CD34.<br></td>
	</tr>
	<tr>
		<td width="150">pb_bm_cb</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Sample origin (peripheral blood, bone marrow or cord blood).<br></td>
	</tr>
	<tr>
		<td width="150">age_years</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Age in years.<br></td>
	</tr>
	<tr>
		<td width="150">cytogenetics</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Cytogenetics (where NK = Normal Karyotype).<br></td>
	</tr>
	<tr>
		<td width="150">os_months</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Overall survival.<br></td>
	</tr>
	<tr>
		<td width="150">efs_months</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Event free survival.<br></td>
	</tr>
	<tr>
		<td width="150">cr</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Complete remission.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="hemoGene_entity">File: hemogene.txt</h3> 
<p>Contents:<br>  Trait annotations specific for genes.
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Main symbol this gene is known by (not necessarily unique, in constrast to 'name').<br></td>
	</tr>
	<tr>
		<td width="150">control</td>
		<td width="50">bool</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Indicating whether this is a 'housekeeping' gene that can be used as control.<br></td>
	</tr>
	<tr>
		<td width="150">orientation</td>
		<td width="50">enum</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Orientation of the gene on the genome (F=forward, R=reverse).<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="hemoProbe_entity">File: hemoprobe.txt</h3> 
<p>Contents:<br>  A piece of sequence that reports for the expression of
				a gene, typically spotted onto a microarray.
			
</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>human-readable name.<br></td>
	</tr>
	<tr>
		<td width="150">description</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>description field.<br></td>
	</tr>
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the Study that this data element is part of.
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">ontologyreference_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>(Optional) Reference to the formal ontology definition for this element, e.g. 'Animal' or 'GWAS protocol'.
		This xref uses {ontologyreference_name} to find related elements in file <a href="#ontologyTerm_entity">ontologyTerm.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">mref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Alternative identifiers or symbols that this element is known by..
		This mref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		. More than one reference can be added separated by '|', for example: ref1|ref2|ref3.</td>
	</tr>	
	<tr>
		<td width="150">label</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>User friendly textual representation of this ObservationElement. For example: 'male',     'mouse 3 in cage 7' or 'TRA-2 like protein'. Label allows for human-readable name that is potentially not unique.<br></td>
	</tr>
	<tr>
		<td width="150">chromosome_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Reference to the chromosome this     position belongs to..
		This xref uses {chromosome_name} to find related elements in file <a href="#chromosome_entity">chromosome.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">cm</td>
		<td width="50">decimal</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>genetic map position in centi morgan (cM).<br></td>
	</tr>
	<tr>
		<td width="150">bpstart</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (5') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">bpend</td>
		<td width="50">long</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>numeric basepair postion (3') on the chromosome.<br></td>
	</tr>
	<tr>
		<td width="150">seq</td>
		<td width="50">text</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The FASTA text representation of the sequence.<br></td>
	</tr>
	<tr>
		<td width="150">symbol</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>todo.<br></td>
	</tr>
	<tr>
		<td width="150">probeset_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>Optional: probeset this probe belongs to (e.g., in Affymetrix assays)..
		This xref uses {probeset_name} to find related elements in file <a href="#probeSet_entity">probeSet.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">xref</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The gene this probe reports for..
		This xref uses {reportsfor_name} to find related elements in file <a href="#hemoGene_entity">hemoGene.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">entrezid</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The entrez ID for the probe.<br></td>
	</tr>
	<tr>
		<td width="150">refseqid</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>The refseq ID for the probe.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (name, investigation) should be unique.</td></tr>
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>


<h3 id="hemoSampleGroup_entity">File: hemosamplegroup.txt</h3> 
<p>Contents:<br> Sample classification (ALL CD34+, AML CD34-, AML CD34+, AML MNC, BC CML, BM CD34+, BM post ASCT, BM retroviral model, CB CD34+, CB retroviral model, mob PBSC, NA, NSG, stroma)
			
.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">id</td>
		<td width="50">int</td>
		<td width="20">&nbsp;</td>
		<td width="50">n+1</td>
		<td>automatically generated id.<br></td>
	</tr>
	<tr>
		<td width="150">name</td>
		<td width="50">string</td>
		<td width="20">&nbsp;</td>
		<td width="50">&nbsp;</td>
		<td>name.<br></td>
	</tr>
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Constraint: values in column name should unique.</td></tr>
</table>
</p>



<h1>Appendix: documentation of the mref tables</h1>
<h2>hemodb file types</h2>
<h3 id="observedInference_derivedFrom_entity">File: observedinference_derivedfrom.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'ObservedInference.derivedFrom'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">derivedfrom_id<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {derivedfrom_id} to find related elements in file <a href="#observedValue_entity">observedValue.txt</a> based on unique column {id}.
		</td>
	</tr>	
	<tr>
		<td width="150">observedinference_id<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {observedinference_id} to find related elements in file <a href="#observedInference_entity">observedInference.txt</a> based on unique column {id}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (derivedfrom, observedinference) should be unique.</td></tr>
</table>
</p>


<h3 id="investigation_contacts_entity">File: investigation_contacts.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'Investigation.contacts'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">contacts_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {contacts_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">investigation_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {investigation_name} to find related elements in file <a href="#investigation_entity">investigation.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (contacts, investigation) should be unique.</td></tr>
</table>
</p>


<h3 id="observationElement_AlternateId_entity">File: observationelement_alternateid.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'ObservationElement.AlternateId'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">alternateid_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {alternateid_name} to find related elements in file <a href="#alternateId_entity">alternateId.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">observationelement_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {observationelement_name} to find related elements in file <a href="#observationElement_entity">observationElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (alternateid, observationelement) should be unique.</td></tr>
</table>
</p>


<h3 id="measurement_categories_entity">File: measurement_categories.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'Measurement.categories'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">categories_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {categories_name} to find related elements in file <a href="#category_entity">category.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">measurement_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {measurement_name} to find related elements in file <a href="#measurement_entity">measurement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (categories, measurement) should be unique.</td></tr>
</table>
</p>


<h3 id="panel_Individuals_entity">File: panel_individuals.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'Panel.Individuals'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">individuals_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {individuals_name} to find related elements in file <a href="#individual_entity">individual.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">panel_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {panel_name} to find related elements in file <a href="#panel_entity">panel.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (individuals, panel) should be unique.</td></tr>
</table>
</p>


<h3 id="panel_FounderPanels_entity">File: panel_founderpanels.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'Panel.FounderPanels'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">founderpanels_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {founderpanels_name} to find related elements in file <a href="#panel_entity">panel.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">panel_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {panel_name} to find related elements in file <a href="#panel_entity">panel.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (founderpanels, panel) should be unique.</td></tr>
</table>
</p>


<h3 id="protocol_Features_entity">File: protocol_features.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'Protocol.Features'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">features_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {features_name} to find related elements in file <a href="#observableFeature_entity">observableFeature.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (features, protocol) should be unique.</td></tr>
</table>
</p>


<h3 id="protocol_subprotocols_entity">File: protocol_subprotocols.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'Protocol.subprotocols'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">subprotocols_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {subprotocols_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocol_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {protocol_name} to find related elements in file <a href="#protocol_entity">protocol.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (subprotocols, protocol) should be unique.</td></tr>
</table>
</p>


<h3 id="protocolApplication_Performer_entity">File: protocolapplication_performer.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'ProtocolApplication.Performer'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">performer_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {performer_name} to find related elements in file <a href="#person_entity">person.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">protocolapplication_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {protocolapplication_name} to find related elements in file <a href="#protocolApplication_entity">protocolApplication.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (performer, protocolapplication) should be unique.</td></tr>
</table>
</p>


<h3 id="workflowElement_PreviousSteps_entity">File: workflowelement_previoussteps.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'WorkflowElement.PreviousSteps'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">previoussteps_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {previoussteps_name} to find related elements in file <a href="#workflowElement_entity">workflowElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">workflowelement_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {workflowelement_name} to find related elements in file <a href="#workflowElement_entity">workflowElement.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (previoussteps, workflowelement) should be unique.</td></tr>
</table>
</p>


<h3 id="marker_ReportsFor_entity">File: marker_reportsfor.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'Marker.ReportsFor'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">reportsfor_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {reportsfor_name} to find related elements in file <a href="#marker_entity">marker.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">marker_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {marker_name} to find related elements in file <a href="#marker_entity">marker.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (reportsfor, marker) should be unique.</td></tr>
</table>
</p>


<h3 id="sNP_Polymorphism_entity">File: snp_polymorphism.txt</h3> 
<p>Contents:<br> Link table for many-to-many relationship 'SNP.Polymorphism'.</p>
<p>Structure:<br>
<table width="100%" cellspacing="0" border="1" bordercolor="#000000">
	<!-- table header -->
	<tr>
		<th>column name</th>
		<th>type</th>
		<th>required?</th>
		<th>auto/default</th>
		<th>description</th>
	</tr>
	
	<!-- all required fields -->
	<tr>
		<td width="150">polymorphism_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {polymorphism_name} to find related elements in file <a href="#polymorphism_entity">polymorphism.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<tr>
		<td width="150">snp_name<br></td>
		<td width="50">xref</td>
		<td width="20">YES</td>
		<td width="50">&nbsp;</td>
		<td>
		This xref uses {snp_name} to find related elements in file <a href="#sNP_entity">sNP.txt</a> based on unique column {name}.
		</td>
	</tr>	
	<!-- all optional fields -->
	<!-- all the uniques -->
<tr><td colspan="5">Contraint: values in the combined columns (polymorphism, snp) should be unique.</td></tr>
</table>
</p>



</body></html>

